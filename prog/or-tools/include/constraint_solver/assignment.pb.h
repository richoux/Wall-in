// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: constraint_solver/assignment.proto

#ifndef PROTOBUF_constraint_5fsolver_2fassignment_2eproto__INCLUDED
#define PROTOBUF_constraint_5fsolver_2fassignment_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace operations_research {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_constraint_5fsolver_2fassignment_2eproto();
void protobuf_AssignDesc_constraint_5fsolver_2fassignment_2eproto();
void protobuf_ShutdownFile_constraint_5fsolver_2fassignment_2eproto();

class IntVarAssignmentProto;
class IntervalVarAssignmentProto;
class SequenceVarAssignmentProto;
class WorkerInfo;
class AssignmentProto;

// ===================================================================

class IntVarAssignmentProto : public ::google::protobuf::Message {
 public:
  IntVarAssignmentProto();
  virtual ~IntVarAssignmentProto();

  IntVarAssignmentProto(const IntVarAssignmentProto& from);

  inline IntVarAssignmentProto& operator=(const IntVarAssignmentProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntVarAssignmentProto& default_instance();

  void Swap(IntVarAssignmentProto* other);

  // implements Message ----------------------------------------------

  IntVarAssignmentProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IntVarAssignmentProto& from);
  void MergeFrom(const IntVarAssignmentProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string var_id = 1;
  inline bool has_var_id() const;
  inline void clear_var_id();
  static const int kVarIdFieldNumber = 1;
  inline const ::std::string& var_id() const;
  inline void set_var_id(const ::std::string& value);
  inline void set_var_id(const char* value);
  inline void set_var_id(const char* value, size_t size);
  inline ::std::string* mutable_var_id();
  inline ::std::string* release_var_id();
  inline void set_allocated_var_id(::std::string* var_id);

  // required int64 min = 2;
  inline bool has_min() const;
  inline void clear_min();
  static const int kMinFieldNumber = 2;
  inline ::google::protobuf::int64 min() const;
  inline void set_min(::google::protobuf::int64 value);

  // optional int64 max = 3;
  inline bool has_max() const;
  inline void clear_max();
  static const int kMaxFieldNumber = 3;
  inline ::google::protobuf::int64 max() const;
  inline void set_max(::google::protobuf::int64 value);

  // optional bool active = 4 [default = true];
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 4;
  inline bool active() const;
  inline void set_active(bool value);

  // @@protoc_insertion_point(class_scope:operations_research.IntVarAssignmentProto)
 private:
  inline void set_has_var_id();
  inline void clear_has_var_id();
  inline void set_has_min();
  inline void clear_has_min();
  inline void set_has_max();
  inline void clear_has_max();
  inline void set_has_active();
  inline void clear_has_active();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* var_id_;
  ::google::protobuf::int64 min_;
  ::google::protobuf::int64 max_;
  bool active_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_constraint_5fsolver_2fassignment_2eproto();
  friend void protobuf_AssignDesc_constraint_5fsolver_2fassignment_2eproto();
  friend void protobuf_ShutdownFile_constraint_5fsolver_2fassignment_2eproto();

  void InitAsDefaultInstance();
  static IntVarAssignmentProto* default_instance_;
};
// -------------------------------------------------------------------

class IntervalVarAssignmentProto : public ::google::protobuf::Message {
 public:
  IntervalVarAssignmentProto();
  virtual ~IntervalVarAssignmentProto();

  IntervalVarAssignmentProto(const IntervalVarAssignmentProto& from);

  inline IntervalVarAssignmentProto& operator=(const IntervalVarAssignmentProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntervalVarAssignmentProto& default_instance();

  void Swap(IntervalVarAssignmentProto* other);

  // implements Message ----------------------------------------------

  IntervalVarAssignmentProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IntervalVarAssignmentProto& from);
  void MergeFrom(const IntervalVarAssignmentProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string var_id = 1;
  inline bool has_var_id() const;
  inline void clear_var_id();
  static const int kVarIdFieldNumber = 1;
  inline const ::std::string& var_id() const;
  inline void set_var_id(const ::std::string& value);
  inline void set_var_id(const char* value);
  inline void set_var_id(const char* value, size_t size);
  inline ::std::string* mutable_var_id();
  inline ::std::string* release_var_id();
  inline void set_allocated_var_id(::std::string* var_id);

  // required int64 start_min = 2;
  inline bool has_start_min() const;
  inline void clear_start_min();
  static const int kStartMinFieldNumber = 2;
  inline ::google::protobuf::int64 start_min() const;
  inline void set_start_min(::google::protobuf::int64 value);

  // optional int64 start_max = 3;
  inline bool has_start_max() const;
  inline void clear_start_max();
  static const int kStartMaxFieldNumber = 3;
  inline ::google::protobuf::int64 start_max() const;
  inline void set_start_max(::google::protobuf::int64 value);

  // required int64 duration_min = 4;
  inline bool has_duration_min() const;
  inline void clear_duration_min();
  static const int kDurationMinFieldNumber = 4;
  inline ::google::protobuf::int64 duration_min() const;
  inline void set_duration_min(::google::protobuf::int64 value);

  // optional int64 duration_max = 5;
  inline bool has_duration_max() const;
  inline void clear_duration_max();
  static const int kDurationMaxFieldNumber = 5;
  inline ::google::protobuf::int64 duration_max() const;
  inline void set_duration_max(::google::protobuf::int64 value);

  // required int64 end_min = 6;
  inline bool has_end_min() const;
  inline void clear_end_min();
  static const int kEndMinFieldNumber = 6;
  inline ::google::protobuf::int64 end_min() const;
  inline void set_end_min(::google::protobuf::int64 value);

  // optional int64 end_max = 7;
  inline bool has_end_max() const;
  inline void clear_end_max();
  static const int kEndMaxFieldNumber = 7;
  inline ::google::protobuf::int64 end_max() const;
  inline void set_end_max(::google::protobuf::int64 value);

  // required int64 performed_min = 8;
  inline bool has_performed_min() const;
  inline void clear_performed_min();
  static const int kPerformedMinFieldNumber = 8;
  inline ::google::protobuf::int64 performed_min() const;
  inline void set_performed_min(::google::protobuf::int64 value);

  // optional int64 performed_max = 9;
  inline bool has_performed_max() const;
  inline void clear_performed_max();
  static const int kPerformedMaxFieldNumber = 9;
  inline ::google::protobuf::int64 performed_max() const;
  inline void set_performed_max(::google::protobuf::int64 value);

  // optional bool active = 10 [default = true];
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 10;
  inline bool active() const;
  inline void set_active(bool value);

  // @@protoc_insertion_point(class_scope:operations_research.IntervalVarAssignmentProto)
 private:
  inline void set_has_var_id();
  inline void clear_has_var_id();
  inline void set_has_start_min();
  inline void clear_has_start_min();
  inline void set_has_start_max();
  inline void clear_has_start_max();
  inline void set_has_duration_min();
  inline void clear_has_duration_min();
  inline void set_has_duration_max();
  inline void clear_has_duration_max();
  inline void set_has_end_min();
  inline void clear_has_end_min();
  inline void set_has_end_max();
  inline void clear_has_end_max();
  inline void set_has_performed_min();
  inline void clear_has_performed_min();
  inline void set_has_performed_max();
  inline void clear_has_performed_max();
  inline void set_has_active();
  inline void clear_has_active();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* var_id_;
  ::google::protobuf::int64 start_min_;
  ::google::protobuf::int64 start_max_;
  ::google::protobuf::int64 duration_min_;
  ::google::protobuf::int64 duration_max_;
  ::google::protobuf::int64 end_min_;
  ::google::protobuf::int64 end_max_;
  ::google::protobuf::int64 performed_min_;
  ::google::protobuf::int64 performed_max_;
  bool active_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_constraint_5fsolver_2fassignment_2eproto();
  friend void protobuf_AssignDesc_constraint_5fsolver_2fassignment_2eproto();
  friend void protobuf_ShutdownFile_constraint_5fsolver_2fassignment_2eproto();

  void InitAsDefaultInstance();
  static IntervalVarAssignmentProto* default_instance_;
};
// -------------------------------------------------------------------

class SequenceVarAssignmentProto : public ::google::protobuf::Message {
 public:
  SequenceVarAssignmentProto();
  virtual ~SequenceVarAssignmentProto();

  SequenceVarAssignmentProto(const SequenceVarAssignmentProto& from);

  inline SequenceVarAssignmentProto& operator=(const SequenceVarAssignmentProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SequenceVarAssignmentProto& default_instance();

  void Swap(SequenceVarAssignmentProto* other);

  // implements Message ----------------------------------------------

  SequenceVarAssignmentProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SequenceVarAssignmentProto& from);
  void MergeFrom(const SequenceVarAssignmentProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string var_id = 1;
  inline bool has_var_id() const;
  inline void clear_var_id();
  static const int kVarIdFieldNumber = 1;
  inline const ::std::string& var_id() const;
  inline void set_var_id(const ::std::string& value);
  inline void set_var_id(const char* value);
  inline void set_var_id(const char* value, size_t size);
  inline ::std::string* mutable_var_id();
  inline ::std::string* release_var_id();
  inline void set_allocated_var_id(::std::string* var_id);

  // repeated int32 forward_sequence = 2;
  inline int forward_sequence_size() const;
  inline void clear_forward_sequence();
  static const int kForwardSequenceFieldNumber = 2;
  inline ::google::protobuf::int32 forward_sequence(int index) const;
  inline void set_forward_sequence(int index, ::google::protobuf::int32 value);
  inline void add_forward_sequence(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      forward_sequence() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_forward_sequence();

  // repeated int32 backward_sequence = 3;
  inline int backward_sequence_size() const;
  inline void clear_backward_sequence();
  static const int kBackwardSequenceFieldNumber = 3;
  inline ::google::protobuf::int32 backward_sequence(int index) const;
  inline void set_backward_sequence(int index, ::google::protobuf::int32 value);
  inline void add_backward_sequence(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      backward_sequence() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_backward_sequence();

  // repeated int32 unperformed = 4;
  inline int unperformed_size() const;
  inline void clear_unperformed();
  static const int kUnperformedFieldNumber = 4;
  inline ::google::protobuf::int32 unperformed(int index) const;
  inline void set_unperformed(int index, ::google::protobuf::int32 value);
  inline void add_unperformed(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      unperformed() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_unperformed();

  // optional bool active = 5 [default = true];
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 5;
  inline bool active() const;
  inline void set_active(bool value);

  // @@protoc_insertion_point(class_scope:operations_research.SequenceVarAssignmentProto)
 private:
  inline void set_has_var_id();
  inline void clear_has_var_id();
  inline void set_has_active();
  inline void clear_has_active();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* var_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > forward_sequence_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > backward_sequence_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > unperformed_;
  bool active_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_constraint_5fsolver_2fassignment_2eproto();
  friend void protobuf_AssignDesc_constraint_5fsolver_2fassignment_2eproto();
  friend void protobuf_ShutdownFile_constraint_5fsolver_2fassignment_2eproto();

  void InitAsDefaultInstance();
  static SequenceVarAssignmentProto* default_instance_;
};
// -------------------------------------------------------------------

class WorkerInfo : public ::google::protobuf::Message {
 public:
  WorkerInfo();
  virtual ~WorkerInfo();

  WorkerInfo(const WorkerInfo& from);

  inline WorkerInfo& operator=(const WorkerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WorkerInfo& default_instance();

  void Swap(WorkerInfo* other);

  // implements Message ----------------------------------------------

  WorkerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WorkerInfo& from);
  void MergeFrom(const WorkerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 worker_id = 1;
  inline bool has_worker_id() const;
  inline void clear_worker_id();
  static const int kWorkerIdFieldNumber = 1;
  inline ::google::protobuf::int32 worker_id() const;
  inline void set_worker_id(::google::protobuf::int32 value);

  // optional string bns = 2;
  inline bool has_bns() const;
  inline void clear_bns();
  static const int kBnsFieldNumber = 2;
  inline const ::std::string& bns() const;
  inline void set_bns(const ::std::string& value);
  inline void set_bns(const char* value);
  inline void set_bns(const char* value, size_t size);
  inline ::std::string* mutable_bns();
  inline ::std::string* release_bns();
  inline void set_allocated_bns(::std::string* bns);

  // @@protoc_insertion_point(class_scope:operations_research.WorkerInfo)
 private:
  inline void set_has_worker_id();
  inline void clear_has_worker_id();
  inline void set_has_bns();
  inline void clear_has_bns();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* bns_;
  ::google::protobuf::int32 worker_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_constraint_5fsolver_2fassignment_2eproto();
  friend void protobuf_AssignDesc_constraint_5fsolver_2fassignment_2eproto();
  friend void protobuf_ShutdownFile_constraint_5fsolver_2fassignment_2eproto();

  void InitAsDefaultInstance();
  static WorkerInfo* default_instance_;
};
// -------------------------------------------------------------------

class AssignmentProto : public ::google::protobuf::Message {
 public:
  AssignmentProto();
  virtual ~AssignmentProto();

  AssignmentProto(const AssignmentProto& from);

  inline AssignmentProto& operator=(const AssignmentProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssignmentProto& default_instance();

  void Swap(AssignmentProto* other);

  // implements Message ----------------------------------------------

  AssignmentProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssignmentProto& from);
  void MergeFrom(const AssignmentProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .operations_research.IntVarAssignmentProto int_var_assignment = 1;
  inline int int_var_assignment_size() const;
  inline void clear_int_var_assignment();
  static const int kIntVarAssignmentFieldNumber = 1;
  inline const ::operations_research::IntVarAssignmentProto& int_var_assignment(int index) const;
  inline ::operations_research::IntVarAssignmentProto* mutable_int_var_assignment(int index);
  inline ::operations_research::IntVarAssignmentProto* add_int_var_assignment();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::IntVarAssignmentProto >&
      int_var_assignment() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::IntVarAssignmentProto >*
      mutable_int_var_assignment();

  // repeated .operations_research.IntervalVarAssignmentProto interval_var_assignment = 2;
  inline int interval_var_assignment_size() const;
  inline void clear_interval_var_assignment();
  static const int kIntervalVarAssignmentFieldNumber = 2;
  inline const ::operations_research::IntervalVarAssignmentProto& interval_var_assignment(int index) const;
  inline ::operations_research::IntervalVarAssignmentProto* mutable_interval_var_assignment(int index);
  inline ::operations_research::IntervalVarAssignmentProto* add_interval_var_assignment();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::IntervalVarAssignmentProto >&
      interval_var_assignment() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::IntervalVarAssignmentProto >*
      mutable_interval_var_assignment();

  // repeated .operations_research.SequenceVarAssignmentProto sequence_var_assignment = 6;
  inline int sequence_var_assignment_size() const;
  inline void clear_sequence_var_assignment();
  static const int kSequenceVarAssignmentFieldNumber = 6;
  inline const ::operations_research::SequenceVarAssignmentProto& sequence_var_assignment(int index) const;
  inline ::operations_research::SequenceVarAssignmentProto* mutable_sequence_var_assignment(int index);
  inline ::operations_research::SequenceVarAssignmentProto* add_sequence_var_assignment();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::SequenceVarAssignmentProto >&
      sequence_var_assignment() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::SequenceVarAssignmentProto >*
      mutable_sequence_var_assignment();

  // optional .operations_research.IntVarAssignmentProto objective = 3;
  inline bool has_objective() const;
  inline void clear_objective();
  static const int kObjectiveFieldNumber = 3;
  inline const ::operations_research::IntVarAssignmentProto& objective() const;
  inline ::operations_research::IntVarAssignmentProto* mutable_objective();
  inline ::operations_research::IntVarAssignmentProto* release_objective();
  inline void set_allocated_objective(::operations_research::IntVarAssignmentProto* objective);

  // optional .operations_research.WorkerInfo worker_info = 4;
  inline bool has_worker_info() const;
  inline void clear_worker_info();
  static const int kWorkerInfoFieldNumber = 4;
  inline const ::operations_research::WorkerInfo& worker_info() const;
  inline ::operations_research::WorkerInfo* mutable_worker_info();
  inline ::operations_research::WorkerInfo* release_worker_info();
  inline void set_allocated_worker_info(::operations_research::WorkerInfo* worker_info);

  // optional bool is_valid = 5 [default = true];
  inline bool has_is_valid() const;
  inline void clear_is_valid();
  static const int kIsValidFieldNumber = 5;
  inline bool is_valid() const;
  inline void set_is_valid(bool value);

  // @@protoc_insertion_point(class_scope:operations_research.AssignmentProto)
 private:
  inline void set_has_objective();
  inline void clear_has_objective();
  inline void set_has_worker_info();
  inline void clear_has_worker_info();
  inline void set_has_is_valid();
  inline void clear_has_is_valid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::operations_research::IntVarAssignmentProto > int_var_assignment_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::IntervalVarAssignmentProto > interval_var_assignment_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::SequenceVarAssignmentProto > sequence_var_assignment_;
  ::operations_research::IntVarAssignmentProto* objective_;
  ::operations_research::WorkerInfo* worker_info_;
  bool is_valid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_constraint_5fsolver_2fassignment_2eproto();
  friend void protobuf_AssignDesc_constraint_5fsolver_2fassignment_2eproto();
  friend void protobuf_ShutdownFile_constraint_5fsolver_2fassignment_2eproto();

  void InitAsDefaultInstance();
  static AssignmentProto* default_instance_;
};
// ===================================================================


// ===================================================================

// IntVarAssignmentProto

// required string var_id = 1;
inline bool IntVarAssignmentProto::has_var_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IntVarAssignmentProto::set_has_var_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IntVarAssignmentProto::clear_has_var_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IntVarAssignmentProto::clear_var_id() {
  if (var_id_ != &::google::protobuf::internal::kEmptyString) {
    var_id_->clear();
  }
  clear_has_var_id();
}
inline const ::std::string& IntVarAssignmentProto::var_id() const {
  return *var_id_;
}
inline void IntVarAssignmentProto::set_var_id(const ::std::string& value) {
  set_has_var_id();
  if (var_id_ == &::google::protobuf::internal::kEmptyString) {
    var_id_ = new ::std::string;
  }
  var_id_->assign(value);
}
inline void IntVarAssignmentProto::set_var_id(const char* value) {
  set_has_var_id();
  if (var_id_ == &::google::protobuf::internal::kEmptyString) {
    var_id_ = new ::std::string;
  }
  var_id_->assign(value);
}
inline void IntVarAssignmentProto::set_var_id(const char* value, size_t size) {
  set_has_var_id();
  if (var_id_ == &::google::protobuf::internal::kEmptyString) {
    var_id_ = new ::std::string;
  }
  var_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IntVarAssignmentProto::mutable_var_id() {
  set_has_var_id();
  if (var_id_ == &::google::protobuf::internal::kEmptyString) {
    var_id_ = new ::std::string;
  }
  return var_id_;
}
inline ::std::string* IntVarAssignmentProto::release_var_id() {
  clear_has_var_id();
  if (var_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = var_id_;
    var_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IntVarAssignmentProto::set_allocated_var_id(::std::string* var_id) {
  if (var_id_ != &::google::protobuf::internal::kEmptyString) {
    delete var_id_;
  }
  if (var_id) {
    set_has_var_id();
    var_id_ = var_id;
  } else {
    clear_has_var_id();
    var_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 min = 2;
inline bool IntVarAssignmentProto::has_min() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IntVarAssignmentProto::set_has_min() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IntVarAssignmentProto::clear_has_min() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IntVarAssignmentProto::clear_min() {
  min_ = GOOGLE_LONGLONG(0);
  clear_has_min();
}
inline ::google::protobuf::int64 IntVarAssignmentProto::min() const {
  return min_;
}
inline void IntVarAssignmentProto::set_min(::google::protobuf::int64 value) {
  set_has_min();
  min_ = value;
}

// optional int64 max = 3;
inline bool IntVarAssignmentProto::has_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IntVarAssignmentProto::set_has_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IntVarAssignmentProto::clear_has_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IntVarAssignmentProto::clear_max() {
  max_ = GOOGLE_LONGLONG(0);
  clear_has_max();
}
inline ::google::protobuf::int64 IntVarAssignmentProto::max() const {
  return max_;
}
inline void IntVarAssignmentProto::set_max(::google::protobuf::int64 value) {
  set_has_max();
  max_ = value;
}

// optional bool active = 4 [default = true];
inline bool IntVarAssignmentProto::has_active() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IntVarAssignmentProto::set_has_active() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IntVarAssignmentProto::clear_has_active() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IntVarAssignmentProto::clear_active() {
  active_ = true;
  clear_has_active();
}
inline bool IntVarAssignmentProto::active() const {
  return active_;
}
inline void IntVarAssignmentProto::set_active(bool value) {
  set_has_active();
  active_ = value;
}

// -------------------------------------------------------------------

// IntervalVarAssignmentProto

// required string var_id = 1;
inline bool IntervalVarAssignmentProto::has_var_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IntervalVarAssignmentProto::set_has_var_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IntervalVarAssignmentProto::clear_has_var_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IntervalVarAssignmentProto::clear_var_id() {
  if (var_id_ != &::google::protobuf::internal::kEmptyString) {
    var_id_->clear();
  }
  clear_has_var_id();
}
inline const ::std::string& IntervalVarAssignmentProto::var_id() const {
  return *var_id_;
}
inline void IntervalVarAssignmentProto::set_var_id(const ::std::string& value) {
  set_has_var_id();
  if (var_id_ == &::google::protobuf::internal::kEmptyString) {
    var_id_ = new ::std::string;
  }
  var_id_->assign(value);
}
inline void IntervalVarAssignmentProto::set_var_id(const char* value) {
  set_has_var_id();
  if (var_id_ == &::google::protobuf::internal::kEmptyString) {
    var_id_ = new ::std::string;
  }
  var_id_->assign(value);
}
inline void IntervalVarAssignmentProto::set_var_id(const char* value, size_t size) {
  set_has_var_id();
  if (var_id_ == &::google::protobuf::internal::kEmptyString) {
    var_id_ = new ::std::string;
  }
  var_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IntervalVarAssignmentProto::mutable_var_id() {
  set_has_var_id();
  if (var_id_ == &::google::protobuf::internal::kEmptyString) {
    var_id_ = new ::std::string;
  }
  return var_id_;
}
inline ::std::string* IntervalVarAssignmentProto::release_var_id() {
  clear_has_var_id();
  if (var_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = var_id_;
    var_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IntervalVarAssignmentProto::set_allocated_var_id(::std::string* var_id) {
  if (var_id_ != &::google::protobuf::internal::kEmptyString) {
    delete var_id_;
  }
  if (var_id) {
    set_has_var_id();
    var_id_ = var_id;
  } else {
    clear_has_var_id();
    var_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 start_min = 2;
inline bool IntervalVarAssignmentProto::has_start_min() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IntervalVarAssignmentProto::set_has_start_min() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IntervalVarAssignmentProto::clear_has_start_min() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IntervalVarAssignmentProto::clear_start_min() {
  start_min_ = GOOGLE_LONGLONG(0);
  clear_has_start_min();
}
inline ::google::protobuf::int64 IntervalVarAssignmentProto::start_min() const {
  return start_min_;
}
inline void IntervalVarAssignmentProto::set_start_min(::google::protobuf::int64 value) {
  set_has_start_min();
  start_min_ = value;
}

// optional int64 start_max = 3;
inline bool IntervalVarAssignmentProto::has_start_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IntervalVarAssignmentProto::set_has_start_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IntervalVarAssignmentProto::clear_has_start_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IntervalVarAssignmentProto::clear_start_max() {
  start_max_ = GOOGLE_LONGLONG(0);
  clear_has_start_max();
}
inline ::google::protobuf::int64 IntervalVarAssignmentProto::start_max() const {
  return start_max_;
}
inline void IntervalVarAssignmentProto::set_start_max(::google::protobuf::int64 value) {
  set_has_start_max();
  start_max_ = value;
}

// required int64 duration_min = 4;
inline bool IntervalVarAssignmentProto::has_duration_min() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IntervalVarAssignmentProto::set_has_duration_min() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IntervalVarAssignmentProto::clear_has_duration_min() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IntervalVarAssignmentProto::clear_duration_min() {
  duration_min_ = GOOGLE_LONGLONG(0);
  clear_has_duration_min();
}
inline ::google::protobuf::int64 IntervalVarAssignmentProto::duration_min() const {
  return duration_min_;
}
inline void IntervalVarAssignmentProto::set_duration_min(::google::protobuf::int64 value) {
  set_has_duration_min();
  duration_min_ = value;
}

// optional int64 duration_max = 5;
inline bool IntervalVarAssignmentProto::has_duration_max() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IntervalVarAssignmentProto::set_has_duration_max() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IntervalVarAssignmentProto::clear_has_duration_max() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IntervalVarAssignmentProto::clear_duration_max() {
  duration_max_ = GOOGLE_LONGLONG(0);
  clear_has_duration_max();
}
inline ::google::protobuf::int64 IntervalVarAssignmentProto::duration_max() const {
  return duration_max_;
}
inline void IntervalVarAssignmentProto::set_duration_max(::google::protobuf::int64 value) {
  set_has_duration_max();
  duration_max_ = value;
}

// required int64 end_min = 6;
inline bool IntervalVarAssignmentProto::has_end_min() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IntervalVarAssignmentProto::set_has_end_min() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IntervalVarAssignmentProto::clear_has_end_min() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IntervalVarAssignmentProto::clear_end_min() {
  end_min_ = GOOGLE_LONGLONG(0);
  clear_has_end_min();
}
inline ::google::protobuf::int64 IntervalVarAssignmentProto::end_min() const {
  return end_min_;
}
inline void IntervalVarAssignmentProto::set_end_min(::google::protobuf::int64 value) {
  set_has_end_min();
  end_min_ = value;
}

// optional int64 end_max = 7;
inline bool IntervalVarAssignmentProto::has_end_max() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IntervalVarAssignmentProto::set_has_end_max() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IntervalVarAssignmentProto::clear_has_end_max() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IntervalVarAssignmentProto::clear_end_max() {
  end_max_ = GOOGLE_LONGLONG(0);
  clear_has_end_max();
}
inline ::google::protobuf::int64 IntervalVarAssignmentProto::end_max() const {
  return end_max_;
}
inline void IntervalVarAssignmentProto::set_end_max(::google::protobuf::int64 value) {
  set_has_end_max();
  end_max_ = value;
}

// required int64 performed_min = 8;
inline bool IntervalVarAssignmentProto::has_performed_min() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IntervalVarAssignmentProto::set_has_performed_min() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IntervalVarAssignmentProto::clear_has_performed_min() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IntervalVarAssignmentProto::clear_performed_min() {
  performed_min_ = GOOGLE_LONGLONG(0);
  clear_has_performed_min();
}
inline ::google::protobuf::int64 IntervalVarAssignmentProto::performed_min() const {
  return performed_min_;
}
inline void IntervalVarAssignmentProto::set_performed_min(::google::protobuf::int64 value) {
  set_has_performed_min();
  performed_min_ = value;
}

// optional int64 performed_max = 9;
inline bool IntervalVarAssignmentProto::has_performed_max() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IntervalVarAssignmentProto::set_has_performed_max() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IntervalVarAssignmentProto::clear_has_performed_max() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IntervalVarAssignmentProto::clear_performed_max() {
  performed_max_ = GOOGLE_LONGLONG(0);
  clear_has_performed_max();
}
inline ::google::protobuf::int64 IntervalVarAssignmentProto::performed_max() const {
  return performed_max_;
}
inline void IntervalVarAssignmentProto::set_performed_max(::google::protobuf::int64 value) {
  set_has_performed_max();
  performed_max_ = value;
}

// optional bool active = 10 [default = true];
inline bool IntervalVarAssignmentProto::has_active() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void IntervalVarAssignmentProto::set_has_active() {
  _has_bits_[0] |= 0x00000200u;
}
inline void IntervalVarAssignmentProto::clear_has_active() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void IntervalVarAssignmentProto::clear_active() {
  active_ = true;
  clear_has_active();
}
inline bool IntervalVarAssignmentProto::active() const {
  return active_;
}
inline void IntervalVarAssignmentProto::set_active(bool value) {
  set_has_active();
  active_ = value;
}

// -------------------------------------------------------------------

// SequenceVarAssignmentProto

// required string var_id = 1;
inline bool SequenceVarAssignmentProto::has_var_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SequenceVarAssignmentProto::set_has_var_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SequenceVarAssignmentProto::clear_has_var_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SequenceVarAssignmentProto::clear_var_id() {
  if (var_id_ != &::google::protobuf::internal::kEmptyString) {
    var_id_->clear();
  }
  clear_has_var_id();
}
inline const ::std::string& SequenceVarAssignmentProto::var_id() const {
  return *var_id_;
}
inline void SequenceVarAssignmentProto::set_var_id(const ::std::string& value) {
  set_has_var_id();
  if (var_id_ == &::google::protobuf::internal::kEmptyString) {
    var_id_ = new ::std::string;
  }
  var_id_->assign(value);
}
inline void SequenceVarAssignmentProto::set_var_id(const char* value) {
  set_has_var_id();
  if (var_id_ == &::google::protobuf::internal::kEmptyString) {
    var_id_ = new ::std::string;
  }
  var_id_->assign(value);
}
inline void SequenceVarAssignmentProto::set_var_id(const char* value, size_t size) {
  set_has_var_id();
  if (var_id_ == &::google::protobuf::internal::kEmptyString) {
    var_id_ = new ::std::string;
  }
  var_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SequenceVarAssignmentProto::mutable_var_id() {
  set_has_var_id();
  if (var_id_ == &::google::protobuf::internal::kEmptyString) {
    var_id_ = new ::std::string;
  }
  return var_id_;
}
inline ::std::string* SequenceVarAssignmentProto::release_var_id() {
  clear_has_var_id();
  if (var_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = var_id_;
    var_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SequenceVarAssignmentProto::set_allocated_var_id(::std::string* var_id) {
  if (var_id_ != &::google::protobuf::internal::kEmptyString) {
    delete var_id_;
  }
  if (var_id) {
    set_has_var_id();
    var_id_ = var_id;
  } else {
    clear_has_var_id();
    var_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 forward_sequence = 2;
inline int SequenceVarAssignmentProto::forward_sequence_size() const {
  return forward_sequence_.size();
}
inline void SequenceVarAssignmentProto::clear_forward_sequence() {
  forward_sequence_.Clear();
}
inline ::google::protobuf::int32 SequenceVarAssignmentProto::forward_sequence(int index) const {
  return forward_sequence_.Get(index);
}
inline void SequenceVarAssignmentProto::set_forward_sequence(int index, ::google::protobuf::int32 value) {
  forward_sequence_.Set(index, value);
}
inline void SequenceVarAssignmentProto::add_forward_sequence(::google::protobuf::int32 value) {
  forward_sequence_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SequenceVarAssignmentProto::forward_sequence() const {
  return forward_sequence_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SequenceVarAssignmentProto::mutable_forward_sequence() {
  return &forward_sequence_;
}

// repeated int32 backward_sequence = 3;
inline int SequenceVarAssignmentProto::backward_sequence_size() const {
  return backward_sequence_.size();
}
inline void SequenceVarAssignmentProto::clear_backward_sequence() {
  backward_sequence_.Clear();
}
inline ::google::protobuf::int32 SequenceVarAssignmentProto::backward_sequence(int index) const {
  return backward_sequence_.Get(index);
}
inline void SequenceVarAssignmentProto::set_backward_sequence(int index, ::google::protobuf::int32 value) {
  backward_sequence_.Set(index, value);
}
inline void SequenceVarAssignmentProto::add_backward_sequence(::google::protobuf::int32 value) {
  backward_sequence_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SequenceVarAssignmentProto::backward_sequence() const {
  return backward_sequence_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SequenceVarAssignmentProto::mutable_backward_sequence() {
  return &backward_sequence_;
}

// repeated int32 unperformed = 4;
inline int SequenceVarAssignmentProto::unperformed_size() const {
  return unperformed_.size();
}
inline void SequenceVarAssignmentProto::clear_unperformed() {
  unperformed_.Clear();
}
inline ::google::protobuf::int32 SequenceVarAssignmentProto::unperformed(int index) const {
  return unperformed_.Get(index);
}
inline void SequenceVarAssignmentProto::set_unperformed(int index, ::google::protobuf::int32 value) {
  unperformed_.Set(index, value);
}
inline void SequenceVarAssignmentProto::add_unperformed(::google::protobuf::int32 value) {
  unperformed_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SequenceVarAssignmentProto::unperformed() const {
  return unperformed_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SequenceVarAssignmentProto::mutable_unperformed() {
  return &unperformed_;
}

// optional bool active = 5 [default = true];
inline bool SequenceVarAssignmentProto::has_active() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SequenceVarAssignmentProto::set_has_active() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SequenceVarAssignmentProto::clear_has_active() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SequenceVarAssignmentProto::clear_active() {
  active_ = true;
  clear_has_active();
}
inline bool SequenceVarAssignmentProto::active() const {
  return active_;
}
inline void SequenceVarAssignmentProto::set_active(bool value) {
  set_has_active();
  active_ = value;
}

// -------------------------------------------------------------------

// WorkerInfo

// optional int32 worker_id = 1;
inline bool WorkerInfo::has_worker_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WorkerInfo::set_has_worker_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WorkerInfo::clear_has_worker_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WorkerInfo::clear_worker_id() {
  worker_id_ = 0;
  clear_has_worker_id();
}
inline ::google::protobuf::int32 WorkerInfo::worker_id() const {
  return worker_id_;
}
inline void WorkerInfo::set_worker_id(::google::protobuf::int32 value) {
  set_has_worker_id();
  worker_id_ = value;
}

// optional string bns = 2;
inline bool WorkerInfo::has_bns() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WorkerInfo::set_has_bns() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WorkerInfo::clear_has_bns() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WorkerInfo::clear_bns() {
  if (bns_ != &::google::protobuf::internal::kEmptyString) {
    bns_->clear();
  }
  clear_has_bns();
}
inline const ::std::string& WorkerInfo::bns() const {
  return *bns_;
}
inline void WorkerInfo::set_bns(const ::std::string& value) {
  set_has_bns();
  if (bns_ == &::google::protobuf::internal::kEmptyString) {
    bns_ = new ::std::string;
  }
  bns_->assign(value);
}
inline void WorkerInfo::set_bns(const char* value) {
  set_has_bns();
  if (bns_ == &::google::protobuf::internal::kEmptyString) {
    bns_ = new ::std::string;
  }
  bns_->assign(value);
}
inline void WorkerInfo::set_bns(const char* value, size_t size) {
  set_has_bns();
  if (bns_ == &::google::protobuf::internal::kEmptyString) {
    bns_ = new ::std::string;
  }
  bns_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkerInfo::mutable_bns() {
  set_has_bns();
  if (bns_ == &::google::protobuf::internal::kEmptyString) {
    bns_ = new ::std::string;
  }
  return bns_;
}
inline ::std::string* WorkerInfo::release_bns() {
  clear_has_bns();
  if (bns_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bns_;
    bns_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WorkerInfo::set_allocated_bns(::std::string* bns) {
  if (bns_ != &::google::protobuf::internal::kEmptyString) {
    delete bns_;
  }
  if (bns) {
    set_has_bns();
    bns_ = bns;
  } else {
    clear_has_bns();
    bns_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AssignmentProto

// repeated .operations_research.IntVarAssignmentProto int_var_assignment = 1;
inline int AssignmentProto::int_var_assignment_size() const {
  return int_var_assignment_.size();
}
inline void AssignmentProto::clear_int_var_assignment() {
  int_var_assignment_.Clear();
}
inline const ::operations_research::IntVarAssignmentProto& AssignmentProto::int_var_assignment(int index) const {
  return int_var_assignment_.Get(index);
}
inline ::operations_research::IntVarAssignmentProto* AssignmentProto::mutable_int_var_assignment(int index) {
  return int_var_assignment_.Mutable(index);
}
inline ::operations_research::IntVarAssignmentProto* AssignmentProto::add_int_var_assignment() {
  return int_var_assignment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::IntVarAssignmentProto >&
AssignmentProto::int_var_assignment() const {
  return int_var_assignment_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::IntVarAssignmentProto >*
AssignmentProto::mutable_int_var_assignment() {
  return &int_var_assignment_;
}

// repeated .operations_research.IntervalVarAssignmentProto interval_var_assignment = 2;
inline int AssignmentProto::interval_var_assignment_size() const {
  return interval_var_assignment_.size();
}
inline void AssignmentProto::clear_interval_var_assignment() {
  interval_var_assignment_.Clear();
}
inline const ::operations_research::IntervalVarAssignmentProto& AssignmentProto::interval_var_assignment(int index) const {
  return interval_var_assignment_.Get(index);
}
inline ::operations_research::IntervalVarAssignmentProto* AssignmentProto::mutable_interval_var_assignment(int index) {
  return interval_var_assignment_.Mutable(index);
}
inline ::operations_research::IntervalVarAssignmentProto* AssignmentProto::add_interval_var_assignment() {
  return interval_var_assignment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::IntervalVarAssignmentProto >&
AssignmentProto::interval_var_assignment() const {
  return interval_var_assignment_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::IntervalVarAssignmentProto >*
AssignmentProto::mutable_interval_var_assignment() {
  return &interval_var_assignment_;
}

// repeated .operations_research.SequenceVarAssignmentProto sequence_var_assignment = 6;
inline int AssignmentProto::sequence_var_assignment_size() const {
  return sequence_var_assignment_.size();
}
inline void AssignmentProto::clear_sequence_var_assignment() {
  sequence_var_assignment_.Clear();
}
inline const ::operations_research::SequenceVarAssignmentProto& AssignmentProto::sequence_var_assignment(int index) const {
  return sequence_var_assignment_.Get(index);
}
inline ::operations_research::SequenceVarAssignmentProto* AssignmentProto::mutable_sequence_var_assignment(int index) {
  return sequence_var_assignment_.Mutable(index);
}
inline ::operations_research::SequenceVarAssignmentProto* AssignmentProto::add_sequence_var_assignment() {
  return sequence_var_assignment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::SequenceVarAssignmentProto >&
AssignmentProto::sequence_var_assignment() const {
  return sequence_var_assignment_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::SequenceVarAssignmentProto >*
AssignmentProto::mutable_sequence_var_assignment() {
  return &sequence_var_assignment_;
}

// optional .operations_research.IntVarAssignmentProto objective = 3;
inline bool AssignmentProto::has_objective() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AssignmentProto::set_has_objective() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AssignmentProto::clear_has_objective() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AssignmentProto::clear_objective() {
  if (objective_ != NULL) objective_->::operations_research::IntVarAssignmentProto::Clear();
  clear_has_objective();
}
inline const ::operations_research::IntVarAssignmentProto& AssignmentProto::objective() const {
  return objective_ != NULL ? *objective_ : *default_instance_->objective_;
}
inline ::operations_research::IntVarAssignmentProto* AssignmentProto::mutable_objective() {
  set_has_objective();
  if (objective_ == NULL) objective_ = new ::operations_research::IntVarAssignmentProto;
  return objective_;
}
inline ::operations_research::IntVarAssignmentProto* AssignmentProto::release_objective() {
  clear_has_objective();
  ::operations_research::IntVarAssignmentProto* temp = objective_;
  objective_ = NULL;
  return temp;
}
inline void AssignmentProto::set_allocated_objective(::operations_research::IntVarAssignmentProto* objective) {
  delete objective_;
  objective_ = objective;
  if (objective) {
    set_has_objective();
  } else {
    clear_has_objective();
  }
}

// optional .operations_research.WorkerInfo worker_info = 4;
inline bool AssignmentProto::has_worker_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AssignmentProto::set_has_worker_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AssignmentProto::clear_has_worker_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AssignmentProto::clear_worker_info() {
  if (worker_info_ != NULL) worker_info_->::operations_research::WorkerInfo::Clear();
  clear_has_worker_info();
}
inline const ::operations_research::WorkerInfo& AssignmentProto::worker_info() const {
  return worker_info_ != NULL ? *worker_info_ : *default_instance_->worker_info_;
}
inline ::operations_research::WorkerInfo* AssignmentProto::mutable_worker_info() {
  set_has_worker_info();
  if (worker_info_ == NULL) worker_info_ = new ::operations_research::WorkerInfo;
  return worker_info_;
}
inline ::operations_research::WorkerInfo* AssignmentProto::release_worker_info() {
  clear_has_worker_info();
  ::operations_research::WorkerInfo* temp = worker_info_;
  worker_info_ = NULL;
  return temp;
}
inline void AssignmentProto::set_allocated_worker_info(::operations_research::WorkerInfo* worker_info) {
  delete worker_info_;
  worker_info_ = worker_info;
  if (worker_info) {
    set_has_worker_info();
  } else {
    clear_has_worker_info();
  }
}

// optional bool is_valid = 5 [default = true];
inline bool AssignmentProto::has_is_valid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AssignmentProto::set_has_is_valid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AssignmentProto::clear_has_is_valid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AssignmentProto::clear_is_valid() {
  is_valid_ = true;
  clear_has_is_valid();
}
inline bool AssignmentProto::is_valid() const {
  return is_valid_;
}
inline void AssignmentProto::set_is_valid(bool value) {
  set_has_is_valid();
  is_valid_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace operations_research

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_constraint_5fsolver_2fassignment_2eproto__INCLUDED
