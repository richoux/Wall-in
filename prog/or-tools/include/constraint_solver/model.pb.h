// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: constraint_solver/model.proto

#ifndef PROTOBUF_constraint_5fsolver_2fmodel_2eproto__INCLUDED
#define PROTOBUF_constraint_5fsolver_2fmodel_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "constraint_solver/search_limit.pb.h"
// @@protoc_insertion_point(includes)

namespace operations_research {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_constraint_5fsolver_2fmodel_2eproto();
void protobuf_AssignDesc_constraint_5fsolver_2fmodel_2eproto();
void protobuf_ShutdownFile_constraint_5fsolver_2fmodel_2eproto();

class CPIntegerMatrixProto;
class CPArgumentProto;
class CPExtensionProto;
class CPIntegerExpressionProto;
class CPIntervalVariableProto;
class CPSequenceVariableProto;
class CPConstraintProto;
class CPObjectiveProto;
class CPVariableGroup;
class CPModelProto;

// ===================================================================

class CPIntegerMatrixProto : public ::google::protobuf::Message {
 public:
  CPIntegerMatrixProto();
  virtual ~CPIntegerMatrixProto();

  CPIntegerMatrixProto(const CPIntegerMatrixProto& from);

  inline CPIntegerMatrixProto& operator=(const CPIntegerMatrixProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CPIntegerMatrixProto& default_instance();

  void Swap(CPIntegerMatrixProto* other);

  // implements Message ----------------------------------------------

  CPIntegerMatrixProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CPIntegerMatrixProto& from);
  void MergeFrom(const CPIntegerMatrixProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rows = 1;
  inline bool has_rows() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 1;
  inline ::google::protobuf::int32 rows() const;
  inline void set_rows(::google::protobuf::int32 value);

  // required int32 columns = 2;
  inline bool has_columns() const;
  inline void clear_columns();
  static const int kColumnsFieldNumber = 2;
  inline ::google::protobuf::int32 columns() const;
  inline void set_columns(::google::protobuf::int32 value);

  // repeated int64 values = 3;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 3;
  inline ::google::protobuf::int64 values(int index) const;
  inline void set_values(int index, ::google::protobuf::int64 value);
  inline void add_values(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      values() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:operations_research.CPIntegerMatrixProto)
 private:
  inline void set_has_rows();
  inline void clear_has_rows();
  inline void set_has_columns();
  inline void clear_has_columns();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 rows_;
  ::google::protobuf::int32 columns_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > values_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_constraint_5fsolver_2fmodel_2eproto();
  friend void protobuf_AssignDesc_constraint_5fsolver_2fmodel_2eproto();
  friend void protobuf_ShutdownFile_constraint_5fsolver_2fmodel_2eproto();

  void InitAsDefaultInstance();
  static CPIntegerMatrixProto* default_instance_;
};
// -------------------------------------------------------------------

class CPArgumentProto : public ::google::protobuf::Message {
 public:
  CPArgumentProto();
  virtual ~CPArgumentProto();

  CPArgumentProto(const CPArgumentProto& from);

  inline CPArgumentProto& operator=(const CPArgumentProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CPArgumentProto& default_instance();

  void Swap(CPArgumentProto* other);

  // implements Message ----------------------------------------------

  CPArgumentProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CPArgumentProto& from);
  void MergeFrom(const CPArgumentProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 argument_index = 1;
  inline bool has_argument_index() const;
  inline void clear_argument_index();
  static const int kArgumentIndexFieldNumber = 1;
  inline ::google::protobuf::int32 argument_index() const;
  inline void set_argument_index(::google::protobuf::int32 value);

  // optional int64 integer_value = 2;
  inline bool has_integer_value() const;
  inline void clear_integer_value();
  static const int kIntegerValueFieldNumber = 2;
  inline ::google::protobuf::int64 integer_value() const;
  inline void set_integer_value(::google::protobuf::int64 value);

  // repeated int64 integer_array = 3;
  inline int integer_array_size() const;
  inline void clear_integer_array();
  static const int kIntegerArrayFieldNumber = 3;
  inline ::google::protobuf::int64 integer_array(int index) const;
  inline void set_integer_array(int index, ::google::protobuf::int64 value);
  inline void add_integer_array(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      integer_array() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_integer_array();

  // optional int32 integer_expression_index = 4;
  inline bool has_integer_expression_index() const;
  inline void clear_integer_expression_index();
  static const int kIntegerExpressionIndexFieldNumber = 4;
  inline ::google::protobuf::int32 integer_expression_index() const;
  inline void set_integer_expression_index(::google::protobuf::int32 value);

  // repeated int32 integer_expression_array = 5;
  inline int integer_expression_array_size() const;
  inline void clear_integer_expression_array();
  static const int kIntegerExpressionArrayFieldNumber = 5;
  inline ::google::protobuf::int32 integer_expression_array(int index) const;
  inline void set_integer_expression_array(int index, ::google::protobuf::int32 value);
  inline void add_integer_expression_array(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      integer_expression_array() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_integer_expression_array();

  // optional int32 interval_index = 6;
  inline bool has_interval_index() const;
  inline void clear_interval_index();
  static const int kIntervalIndexFieldNumber = 6;
  inline ::google::protobuf::int32 interval_index() const;
  inline void set_interval_index(::google::protobuf::int32 value);

  // repeated int32 interval_array = 7;
  inline int interval_array_size() const;
  inline void clear_interval_array();
  static const int kIntervalArrayFieldNumber = 7;
  inline ::google::protobuf::int32 interval_array(int index) const;
  inline void set_interval_array(int index, ::google::protobuf::int32 value);
  inline void add_interval_array(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      interval_array() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_interval_array();

  // optional int32 sequence_index = 8;
  inline bool has_sequence_index() const;
  inline void clear_sequence_index();
  static const int kSequenceIndexFieldNumber = 8;
  inline ::google::protobuf::int32 sequence_index() const;
  inline void set_sequence_index(::google::protobuf::int32 value);

  // repeated int32 sequence_array = 9;
  inline int sequence_array_size() const;
  inline void clear_sequence_array();
  static const int kSequenceArrayFieldNumber = 9;
  inline ::google::protobuf::int32 sequence_array(int index) const;
  inline void set_sequence_array(int index, ::google::protobuf::int32 value);
  inline void add_sequence_array(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      sequence_array() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_sequence_array();

  // optional .operations_research.CPIntegerMatrixProto integer_matrix = 10;
  inline bool has_integer_matrix() const;
  inline void clear_integer_matrix();
  static const int kIntegerMatrixFieldNumber = 10;
  inline const ::operations_research::CPIntegerMatrixProto& integer_matrix() const;
  inline ::operations_research::CPIntegerMatrixProto* mutable_integer_matrix();
  inline ::operations_research::CPIntegerMatrixProto* release_integer_matrix();
  inline void set_allocated_integer_matrix(::operations_research::CPIntegerMatrixProto* integer_matrix);

  // @@protoc_insertion_point(class_scope:operations_research.CPArgumentProto)
 private:
  inline void set_has_argument_index();
  inline void clear_has_argument_index();
  inline void set_has_integer_value();
  inline void clear_has_integer_value();
  inline void set_has_integer_expression_index();
  inline void clear_has_integer_expression_index();
  inline void set_has_interval_index();
  inline void clear_has_interval_index();
  inline void set_has_sequence_index();
  inline void clear_has_sequence_index();
  inline void set_has_integer_matrix();
  inline void clear_has_integer_matrix();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 integer_value_;
  ::google::protobuf::int32 argument_index_;
  ::google::protobuf::int32 integer_expression_index_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > integer_array_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > integer_expression_array_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > interval_array_;
  ::google::protobuf::int32 interval_index_;
  ::google::protobuf::int32 sequence_index_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > sequence_array_;
  ::operations_research::CPIntegerMatrixProto* integer_matrix_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_constraint_5fsolver_2fmodel_2eproto();
  friend void protobuf_AssignDesc_constraint_5fsolver_2fmodel_2eproto();
  friend void protobuf_ShutdownFile_constraint_5fsolver_2fmodel_2eproto();

  void InitAsDefaultInstance();
  static CPArgumentProto* default_instance_;
};
// -------------------------------------------------------------------

class CPExtensionProto : public ::google::protobuf::Message {
 public:
  CPExtensionProto();
  virtual ~CPExtensionProto();

  CPExtensionProto(const CPExtensionProto& from);

  inline CPExtensionProto& operator=(const CPExtensionProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CPExtensionProto& default_instance();

  void Swap(CPExtensionProto* other);

  // implements Message ----------------------------------------------

  CPExtensionProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CPExtensionProto& from);
  void MergeFrom(const CPExtensionProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type_index = 1;
  inline bool has_type_index() const;
  inline void clear_type_index();
  static const int kTypeIndexFieldNumber = 1;
  inline ::google::protobuf::int32 type_index() const;
  inline void set_type_index(::google::protobuf::int32 value);

  // repeated .operations_research.CPArgumentProto arguments = 2;
  inline int arguments_size() const;
  inline void clear_arguments();
  static const int kArgumentsFieldNumber = 2;
  inline const ::operations_research::CPArgumentProto& arguments(int index) const;
  inline ::operations_research::CPArgumentProto* mutable_arguments(int index);
  inline ::operations_research::CPArgumentProto* add_arguments();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >&
      arguments() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >*
      mutable_arguments();

  // @@protoc_insertion_point(class_scope:operations_research.CPExtensionProto)
 private:
  inline void set_has_type_index();
  inline void clear_has_type_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto > arguments_;
  ::google::protobuf::int32 type_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_constraint_5fsolver_2fmodel_2eproto();
  friend void protobuf_AssignDesc_constraint_5fsolver_2fmodel_2eproto();
  friend void protobuf_ShutdownFile_constraint_5fsolver_2fmodel_2eproto();

  void InitAsDefaultInstance();
  static CPExtensionProto* default_instance_;
};
// -------------------------------------------------------------------

class CPIntegerExpressionProto : public ::google::protobuf::Message {
 public:
  CPIntegerExpressionProto();
  virtual ~CPIntegerExpressionProto();

  CPIntegerExpressionProto(const CPIntegerExpressionProto& from);

  inline CPIntegerExpressionProto& operator=(const CPIntegerExpressionProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CPIntegerExpressionProto& default_instance();

  void Swap(CPIntegerExpressionProto* other);

  // implements Message ----------------------------------------------

  CPIntegerExpressionProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CPIntegerExpressionProto& from);
  void MergeFrom(const CPIntegerExpressionProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // required int32 type_index = 2;
  inline bool has_type_index() const;
  inline void clear_type_index();
  static const int kTypeIndexFieldNumber = 2;
  inline ::google::protobuf::int32 type_index() const;
  inline void set_type_index(::google::protobuf::int32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .operations_research.CPArgumentProto arguments = 4;
  inline int arguments_size() const;
  inline void clear_arguments();
  static const int kArgumentsFieldNumber = 4;
  inline const ::operations_research::CPArgumentProto& arguments(int index) const;
  inline ::operations_research::CPArgumentProto* mutable_arguments(int index);
  inline ::operations_research::CPArgumentProto* add_arguments();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >&
      arguments() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >*
      mutable_arguments();

  // repeated .operations_research.CPExtensionProto extensions = 5;
  inline int extensions_size() const;
  inline void clear_extensions();
  static const int kExtensionsFieldNumber = 5;
  inline const ::operations_research::CPExtensionProto& extensions(int index) const;
  inline ::operations_research::CPExtensionProto* mutable_extensions(int index);
  inline ::operations_research::CPExtensionProto* add_extensions();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPExtensionProto >&
      extensions() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPExtensionProto >*
      mutable_extensions();

  // @@protoc_insertion_point(class_scope:operations_research.CPIntegerExpressionProto)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_type_index();
  inline void clear_has_type_index();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 type_index_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto > arguments_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::CPExtensionProto > extensions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_constraint_5fsolver_2fmodel_2eproto();
  friend void protobuf_AssignDesc_constraint_5fsolver_2fmodel_2eproto();
  friend void protobuf_ShutdownFile_constraint_5fsolver_2fmodel_2eproto();

  void InitAsDefaultInstance();
  static CPIntegerExpressionProto* default_instance_;
};
// -------------------------------------------------------------------

class CPIntervalVariableProto : public ::google::protobuf::Message {
 public:
  CPIntervalVariableProto();
  virtual ~CPIntervalVariableProto();

  CPIntervalVariableProto(const CPIntervalVariableProto& from);

  inline CPIntervalVariableProto& operator=(const CPIntervalVariableProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CPIntervalVariableProto& default_instance();

  void Swap(CPIntervalVariableProto* other);

  // implements Message ----------------------------------------------

  CPIntervalVariableProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CPIntervalVariableProto& from);
  void MergeFrom(const CPIntervalVariableProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // required int32 type_index = 2;
  inline bool has_type_index() const;
  inline void clear_type_index();
  static const int kTypeIndexFieldNumber = 2;
  inline ::google::protobuf::int32 type_index() const;
  inline void set_type_index(::google::protobuf::int32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .operations_research.CPArgumentProto arguments = 4;
  inline int arguments_size() const;
  inline void clear_arguments();
  static const int kArgumentsFieldNumber = 4;
  inline const ::operations_research::CPArgumentProto& arguments(int index) const;
  inline ::operations_research::CPArgumentProto* mutable_arguments(int index);
  inline ::operations_research::CPArgumentProto* add_arguments();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >&
      arguments() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >*
      mutable_arguments();

  // @@protoc_insertion_point(class_scope:operations_research.CPIntervalVariableProto)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_type_index();
  inline void clear_has_type_index();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 type_index_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto > arguments_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_constraint_5fsolver_2fmodel_2eproto();
  friend void protobuf_AssignDesc_constraint_5fsolver_2fmodel_2eproto();
  friend void protobuf_ShutdownFile_constraint_5fsolver_2fmodel_2eproto();

  void InitAsDefaultInstance();
  static CPIntervalVariableProto* default_instance_;
};
// -------------------------------------------------------------------

class CPSequenceVariableProto : public ::google::protobuf::Message {
 public:
  CPSequenceVariableProto();
  virtual ~CPSequenceVariableProto();

  CPSequenceVariableProto(const CPSequenceVariableProto& from);

  inline CPSequenceVariableProto& operator=(const CPSequenceVariableProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CPSequenceVariableProto& default_instance();

  void Swap(CPSequenceVariableProto* other);

  // implements Message ----------------------------------------------

  CPSequenceVariableProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CPSequenceVariableProto& from);
  void MergeFrom(const CPSequenceVariableProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // required int32 type_index = 2;
  inline bool has_type_index() const;
  inline void clear_type_index();
  static const int kTypeIndexFieldNumber = 2;
  inline ::google::protobuf::int32 type_index() const;
  inline void set_type_index(::google::protobuf::int32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .operations_research.CPArgumentProto arguments = 4;
  inline int arguments_size() const;
  inline void clear_arguments();
  static const int kArgumentsFieldNumber = 4;
  inline const ::operations_research::CPArgumentProto& arguments(int index) const;
  inline ::operations_research::CPArgumentProto* mutable_arguments(int index);
  inline ::operations_research::CPArgumentProto* add_arguments();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >&
      arguments() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >*
      mutable_arguments();

  // @@protoc_insertion_point(class_scope:operations_research.CPSequenceVariableProto)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_type_index();
  inline void clear_has_type_index();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 type_index_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto > arguments_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_constraint_5fsolver_2fmodel_2eproto();
  friend void protobuf_AssignDesc_constraint_5fsolver_2fmodel_2eproto();
  friend void protobuf_ShutdownFile_constraint_5fsolver_2fmodel_2eproto();

  void InitAsDefaultInstance();
  static CPSequenceVariableProto* default_instance_;
};
// -------------------------------------------------------------------

class CPConstraintProto : public ::google::protobuf::Message {
 public:
  CPConstraintProto();
  virtual ~CPConstraintProto();

  CPConstraintProto(const CPConstraintProto& from);

  inline CPConstraintProto& operator=(const CPConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CPConstraintProto& default_instance();

  void Swap(CPConstraintProto* other);

  // implements Message ----------------------------------------------

  CPConstraintProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CPConstraintProto& from);
  void MergeFrom(const CPConstraintProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // required int32 type_index = 2;
  inline bool has_type_index() const;
  inline void clear_type_index();
  static const int kTypeIndexFieldNumber = 2;
  inline ::google::protobuf::int32 type_index() const;
  inline void set_type_index(::google::protobuf::int32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .operations_research.CPArgumentProto arguments = 4;
  inline int arguments_size() const;
  inline void clear_arguments();
  static const int kArgumentsFieldNumber = 4;
  inline const ::operations_research::CPArgumentProto& arguments(int index) const;
  inline ::operations_research::CPArgumentProto* mutable_arguments(int index);
  inline ::operations_research::CPArgumentProto* add_arguments();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >&
      arguments() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >*
      mutable_arguments();

  // repeated .operations_research.CPExtensionProto extensions = 5;
  inline int extensions_size() const;
  inline void clear_extensions();
  static const int kExtensionsFieldNumber = 5;
  inline const ::operations_research::CPExtensionProto& extensions(int index) const;
  inline ::operations_research::CPExtensionProto* mutable_extensions(int index);
  inline ::operations_research::CPExtensionProto* add_extensions();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPExtensionProto >&
      extensions() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPExtensionProto >*
      mutable_extensions();

  // @@protoc_insertion_point(class_scope:operations_research.CPConstraintProto)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_type_index();
  inline void clear_has_type_index();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 type_index_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto > arguments_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::CPExtensionProto > extensions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_constraint_5fsolver_2fmodel_2eproto();
  friend void protobuf_AssignDesc_constraint_5fsolver_2fmodel_2eproto();
  friend void protobuf_ShutdownFile_constraint_5fsolver_2fmodel_2eproto();

  void InitAsDefaultInstance();
  static CPConstraintProto* default_instance_;
};
// -------------------------------------------------------------------

class CPObjectiveProto : public ::google::protobuf::Message {
 public:
  CPObjectiveProto();
  virtual ~CPObjectiveProto();

  CPObjectiveProto(const CPObjectiveProto& from);

  inline CPObjectiveProto& operator=(const CPObjectiveProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CPObjectiveProto& default_instance();

  void Swap(CPObjectiveProto* other);

  // implements Message ----------------------------------------------

  CPObjectiveProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CPObjectiveProto& from);
  void MergeFrom(const CPObjectiveProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool maximize = 1;
  inline bool has_maximize() const;
  inline void clear_maximize();
  static const int kMaximizeFieldNumber = 1;
  inline bool maximize() const;
  inline void set_maximize(bool value);

  // required int64 step = 2;
  inline bool has_step() const;
  inline void clear_step();
  static const int kStepFieldNumber = 2;
  inline ::google::protobuf::int64 step() const;
  inline void set_step(::google::protobuf::int64 value);

  // required int32 objective_index = 3;
  inline bool has_objective_index() const;
  inline void clear_objective_index();
  static const int kObjectiveIndexFieldNumber = 3;
  inline ::google::protobuf::int32 objective_index() const;
  inline void set_objective_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:operations_research.CPObjectiveProto)
 private:
  inline void set_has_maximize();
  inline void clear_has_maximize();
  inline void set_has_step();
  inline void clear_has_step();
  inline void set_has_objective_index();
  inline void clear_has_objective_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 step_;
  bool maximize_;
  ::google::protobuf::int32 objective_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_constraint_5fsolver_2fmodel_2eproto();
  friend void protobuf_AssignDesc_constraint_5fsolver_2fmodel_2eproto();
  friend void protobuf_ShutdownFile_constraint_5fsolver_2fmodel_2eproto();

  void InitAsDefaultInstance();
  static CPObjectiveProto* default_instance_;
};
// -------------------------------------------------------------------

class CPVariableGroup : public ::google::protobuf::Message {
 public:
  CPVariableGroup();
  virtual ~CPVariableGroup();

  CPVariableGroup(const CPVariableGroup& from);

  inline CPVariableGroup& operator=(const CPVariableGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CPVariableGroup& default_instance();

  void Swap(CPVariableGroup* other);

  // implements Message ----------------------------------------------

  CPVariableGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CPVariableGroup& from);
  void MergeFrom(const CPVariableGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .operations_research.CPArgumentProto arguments = 1;
  inline int arguments_size() const;
  inline void clear_arguments();
  static const int kArgumentsFieldNumber = 1;
  inline const ::operations_research::CPArgumentProto& arguments(int index) const;
  inline ::operations_research::CPArgumentProto* mutable_arguments(int index);
  inline ::operations_research::CPArgumentProto* add_arguments();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >&
      arguments() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >*
      mutable_arguments();

  // optional string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:operations_research.CPVariableGroup)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto > arguments_;
  ::std::string* type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_constraint_5fsolver_2fmodel_2eproto();
  friend void protobuf_AssignDesc_constraint_5fsolver_2fmodel_2eproto();
  friend void protobuf_ShutdownFile_constraint_5fsolver_2fmodel_2eproto();

  void InitAsDefaultInstance();
  static CPVariableGroup* default_instance_;
};
// -------------------------------------------------------------------

class CPModelProto : public ::google::protobuf::Message {
 public:
  CPModelProto();
  virtual ~CPModelProto();

  CPModelProto(const CPModelProto& from);

  inline CPModelProto& operator=(const CPModelProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CPModelProto& default_instance();

  void Swap(CPModelProto* other);

  // implements Message ----------------------------------------------

  CPModelProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CPModelProto& from);
  void MergeFrom(const CPModelProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model = 1;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 1;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  inline void set_allocated_model(::std::string* model);

  // required int32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // repeated string tags = 3;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 3;
  inline const ::std::string& tags(int index) const;
  inline ::std::string* mutable_tags(int index);
  inline void set_tags(int index, const ::std::string& value);
  inline void set_tags(int index, const char* value);
  inline void set_tags(int index, const char* value, size_t size);
  inline ::std::string* add_tags();
  inline void add_tags(const ::std::string& value);
  inline void add_tags(const char* value);
  inline void add_tags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // repeated .operations_research.CPIntegerExpressionProto expressions = 4;
  inline int expressions_size() const;
  inline void clear_expressions();
  static const int kExpressionsFieldNumber = 4;
  inline const ::operations_research::CPIntegerExpressionProto& expressions(int index) const;
  inline ::operations_research::CPIntegerExpressionProto* mutable_expressions(int index);
  inline ::operations_research::CPIntegerExpressionProto* add_expressions();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPIntegerExpressionProto >&
      expressions() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPIntegerExpressionProto >*
      mutable_expressions();

  // repeated .operations_research.CPIntervalVariableProto intervals = 5;
  inline int intervals_size() const;
  inline void clear_intervals();
  static const int kIntervalsFieldNumber = 5;
  inline const ::operations_research::CPIntervalVariableProto& intervals(int index) const;
  inline ::operations_research::CPIntervalVariableProto* mutable_intervals(int index);
  inline ::operations_research::CPIntervalVariableProto* add_intervals();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPIntervalVariableProto >&
      intervals() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPIntervalVariableProto >*
      mutable_intervals();

  // repeated .operations_research.CPSequenceVariableProto sequences = 6;
  inline int sequences_size() const;
  inline void clear_sequences();
  static const int kSequencesFieldNumber = 6;
  inline const ::operations_research::CPSequenceVariableProto& sequences(int index) const;
  inline ::operations_research::CPSequenceVariableProto* mutable_sequences(int index);
  inline ::operations_research::CPSequenceVariableProto* add_sequences();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPSequenceVariableProto >&
      sequences() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPSequenceVariableProto >*
      mutable_sequences();

  // repeated .operations_research.CPConstraintProto constraints = 7;
  inline int constraints_size() const;
  inline void clear_constraints();
  static const int kConstraintsFieldNumber = 7;
  inline const ::operations_research::CPConstraintProto& constraints(int index) const;
  inline ::operations_research::CPConstraintProto* mutable_constraints(int index);
  inline ::operations_research::CPConstraintProto* add_constraints();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPConstraintProto >&
      constraints() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPConstraintProto >*
      mutable_constraints();

  // optional .operations_research.CPObjectiveProto objective = 8;
  inline bool has_objective() const;
  inline void clear_objective();
  static const int kObjectiveFieldNumber = 8;
  inline const ::operations_research::CPObjectiveProto& objective() const;
  inline ::operations_research::CPObjectiveProto* mutable_objective();
  inline ::operations_research::CPObjectiveProto* release_objective();
  inline void set_allocated_objective(::operations_research::CPObjectiveProto* objective);

  // optional .operations_research.SearchLimitProto search_limit = 9;
  inline bool has_search_limit() const;
  inline void clear_search_limit();
  static const int kSearchLimitFieldNumber = 9;
  inline const ::operations_research::SearchLimitProto& search_limit() const;
  inline ::operations_research::SearchLimitProto* mutable_search_limit();
  inline ::operations_research::SearchLimitProto* release_search_limit();
  inline void set_allocated_search_limit(::operations_research::SearchLimitProto* search_limit);

  // repeated .operations_research.CPVariableGroup variable_groups = 10;
  inline int variable_groups_size() const;
  inline void clear_variable_groups();
  static const int kVariableGroupsFieldNumber = 10;
  inline const ::operations_research::CPVariableGroup& variable_groups(int index) const;
  inline ::operations_research::CPVariableGroup* mutable_variable_groups(int index);
  inline ::operations_research::CPVariableGroup* add_variable_groups();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPVariableGroup >&
      variable_groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPVariableGroup >*
      mutable_variable_groups();

  // optional string license_text = 11;
  inline bool has_license_text() const;
  inline void clear_license_text();
  static const int kLicenseTextFieldNumber = 11;
  inline const ::std::string& license_text() const;
  inline void set_license_text(const ::std::string& value);
  inline void set_license_text(const char* value);
  inline void set_license_text(const char* value, size_t size);
  inline ::std::string* mutable_license_text();
  inline ::std::string* release_license_text();
  inline void set_allocated_license_text(::std::string* license_text);

  // @@protoc_insertion_point(class_scope:operations_research.CPModelProto)
 private:
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_objective();
  inline void clear_has_objective();
  inline void set_has_search_limit();
  inline void clear_has_search_limit();
  inline void set_has_license_text();
  inline void clear_has_license_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* model_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::CPIntegerExpressionProto > expressions_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::CPIntervalVariableProto > intervals_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::CPSequenceVariableProto > sequences_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::CPConstraintProto > constraints_;
  ::operations_research::CPObjectiveProto* objective_;
  ::operations_research::SearchLimitProto* search_limit_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::CPVariableGroup > variable_groups_;
  ::std::string* license_text_;
  ::google::protobuf::int32 version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_constraint_5fsolver_2fmodel_2eproto();
  friend void protobuf_AssignDesc_constraint_5fsolver_2fmodel_2eproto();
  friend void protobuf_ShutdownFile_constraint_5fsolver_2fmodel_2eproto();

  void InitAsDefaultInstance();
  static CPModelProto* default_instance_;
};
// ===================================================================


// ===================================================================

// CPIntegerMatrixProto

// required int32 rows = 1;
inline bool CPIntegerMatrixProto::has_rows() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CPIntegerMatrixProto::set_has_rows() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CPIntegerMatrixProto::clear_has_rows() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CPIntegerMatrixProto::clear_rows() {
  rows_ = 0;
  clear_has_rows();
}
inline ::google::protobuf::int32 CPIntegerMatrixProto::rows() const {
  return rows_;
}
inline void CPIntegerMatrixProto::set_rows(::google::protobuf::int32 value) {
  set_has_rows();
  rows_ = value;
}

// required int32 columns = 2;
inline bool CPIntegerMatrixProto::has_columns() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CPIntegerMatrixProto::set_has_columns() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CPIntegerMatrixProto::clear_has_columns() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CPIntegerMatrixProto::clear_columns() {
  columns_ = 0;
  clear_has_columns();
}
inline ::google::protobuf::int32 CPIntegerMatrixProto::columns() const {
  return columns_;
}
inline void CPIntegerMatrixProto::set_columns(::google::protobuf::int32 value) {
  set_has_columns();
  columns_ = value;
}

// repeated int64 values = 3;
inline int CPIntegerMatrixProto::values_size() const {
  return values_.size();
}
inline void CPIntegerMatrixProto::clear_values() {
  values_.Clear();
}
inline ::google::protobuf::int64 CPIntegerMatrixProto::values(int index) const {
  return values_.Get(index);
}
inline void CPIntegerMatrixProto::set_values(int index, ::google::protobuf::int64 value) {
  values_.Set(index, value);
}
inline void CPIntegerMatrixProto::add_values(::google::protobuf::int64 value) {
  values_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
CPIntegerMatrixProto::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
CPIntegerMatrixProto::mutable_values() {
  return &values_;
}

// -------------------------------------------------------------------

// CPArgumentProto

// required int32 argument_index = 1;
inline bool CPArgumentProto::has_argument_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CPArgumentProto::set_has_argument_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CPArgumentProto::clear_has_argument_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CPArgumentProto::clear_argument_index() {
  argument_index_ = 0;
  clear_has_argument_index();
}
inline ::google::protobuf::int32 CPArgumentProto::argument_index() const {
  return argument_index_;
}
inline void CPArgumentProto::set_argument_index(::google::protobuf::int32 value) {
  set_has_argument_index();
  argument_index_ = value;
}

// optional int64 integer_value = 2;
inline bool CPArgumentProto::has_integer_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CPArgumentProto::set_has_integer_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CPArgumentProto::clear_has_integer_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CPArgumentProto::clear_integer_value() {
  integer_value_ = GOOGLE_LONGLONG(0);
  clear_has_integer_value();
}
inline ::google::protobuf::int64 CPArgumentProto::integer_value() const {
  return integer_value_;
}
inline void CPArgumentProto::set_integer_value(::google::protobuf::int64 value) {
  set_has_integer_value();
  integer_value_ = value;
}

// repeated int64 integer_array = 3;
inline int CPArgumentProto::integer_array_size() const {
  return integer_array_.size();
}
inline void CPArgumentProto::clear_integer_array() {
  integer_array_.Clear();
}
inline ::google::protobuf::int64 CPArgumentProto::integer_array(int index) const {
  return integer_array_.Get(index);
}
inline void CPArgumentProto::set_integer_array(int index, ::google::protobuf::int64 value) {
  integer_array_.Set(index, value);
}
inline void CPArgumentProto::add_integer_array(::google::protobuf::int64 value) {
  integer_array_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
CPArgumentProto::integer_array() const {
  return integer_array_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
CPArgumentProto::mutable_integer_array() {
  return &integer_array_;
}

// optional int32 integer_expression_index = 4;
inline bool CPArgumentProto::has_integer_expression_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CPArgumentProto::set_has_integer_expression_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CPArgumentProto::clear_has_integer_expression_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CPArgumentProto::clear_integer_expression_index() {
  integer_expression_index_ = 0;
  clear_has_integer_expression_index();
}
inline ::google::protobuf::int32 CPArgumentProto::integer_expression_index() const {
  return integer_expression_index_;
}
inline void CPArgumentProto::set_integer_expression_index(::google::protobuf::int32 value) {
  set_has_integer_expression_index();
  integer_expression_index_ = value;
}

// repeated int32 integer_expression_array = 5;
inline int CPArgumentProto::integer_expression_array_size() const {
  return integer_expression_array_.size();
}
inline void CPArgumentProto::clear_integer_expression_array() {
  integer_expression_array_.Clear();
}
inline ::google::protobuf::int32 CPArgumentProto::integer_expression_array(int index) const {
  return integer_expression_array_.Get(index);
}
inline void CPArgumentProto::set_integer_expression_array(int index, ::google::protobuf::int32 value) {
  integer_expression_array_.Set(index, value);
}
inline void CPArgumentProto::add_integer_expression_array(::google::protobuf::int32 value) {
  integer_expression_array_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
CPArgumentProto::integer_expression_array() const {
  return integer_expression_array_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
CPArgumentProto::mutable_integer_expression_array() {
  return &integer_expression_array_;
}

// optional int32 interval_index = 6;
inline bool CPArgumentProto::has_interval_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CPArgumentProto::set_has_interval_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CPArgumentProto::clear_has_interval_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CPArgumentProto::clear_interval_index() {
  interval_index_ = 0;
  clear_has_interval_index();
}
inline ::google::protobuf::int32 CPArgumentProto::interval_index() const {
  return interval_index_;
}
inline void CPArgumentProto::set_interval_index(::google::protobuf::int32 value) {
  set_has_interval_index();
  interval_index_ = value;
}

// repeated int32 interval_array = 7;
inline int CPArgumentProto::interval_array_size() const {
  return interval_array_.size();
}
inline void CPArgumentProto::clear_interval_array() {
  interval_array_.Clear();
}
inline ::google::protobuf::int32 CPArgumentProto::interval_array(int index) const {
  return interval_array_.Get(index);
}
inline void CPArgumentProto::set_interval_array(int index, ::google::protobuf::int32 value) {
  interval_array_.Set(index, value);
}
inline void CPArgumentProto::add_interval_array(::google::protobuf::int32 value) {
  interval_array_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
CPArgumentProto::interval_array() const {
  return interval_array_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
CPArgumentProto::mutable_interval_array() {
  return &interval_array_;
}

// optional int32 sequence_index = 8;
inline bool CPArgumentProto::has_sequence_index() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CPArgumentProto::set_has_sequence_index() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CPArgumentProto::clear_has_sequence_index() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CPArgumentProto::clear_sequence_index() {
  sequence_index_ = 0;
  clear_has_sequence_index();
}
inline ::google::protobuf::int32 CPArgumentProto::sequence_index() const {
  return sequence_index_;
}
inline void CPArgumentProto::set_sequence_index(::google::protobuf::int32 value) {
  set_has_sequence_index();
  sequence_index_ = value;
}

// repeated int32 sequence_array = 9;
inline int CPArgumentProto::sequence_array_size() const {
  return sequence_array_.size();
}
inline void CPArgumentProto::clear_sequence_array() {
  sequence_array_.Clear();
}
inline ::google::protobuf::int32 CPArgumentProto::sequence_array(int index) const {
  return sequence_array_.Get(index);
}
inline void CPArgumentProto::set_sequence_array(int index, ::google::protobuf::int32 value) {
  sequence_array_.Set(index, value);
}
inline void CPArgumentProto::add_sequence_array(::google::protobuf::int32 value) {
  sequence_array_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
CPArgumentProto::sequence_array() const {
  return sequence_array_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
CPArgumentProto::mutable_sequence_array() {
  return &sequence_array_;
}

// optional .operations_research.CPIntegerMatrixProto integer_matrix = 10;
inline bool CPArgumentProto::has_integer_matrix() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CPArgumentProto::set_has_integer_matrix() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CPArgumentProto::clear_has_integer_matrix() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CPArgumentProto::clear_integer_matrix() {
  if (integer_matrix_ != NULL) integer_matrix_->::operations_research::CPIntegerMatrixProto::Clear();
  clear_has_integer_matrix();
}
inline const ::operations_research::CPIntegerMatrixProto& CPArgumentProto::integer_matrix() const {
  return integer_matrix_ != NULL ? *integer_matrix_ : *default_instance_->integer_matrix_;
}
inline ::operations_research::CPIntegerMatrixProto* CPArgumentProto::mutable_integer_matrix() {
  set_has_integer_matrix();
  if (integer_matrix_ == NULL) integer_matrix_ = new ::operations_research::CPIntegerMatrixProto;
  return integer_matrix_;
}
inline ::operations_research::CPIntegerMatrixProto* CPArgumentProto::release_integer_matrix() {
  clear_has_integer_matrix();
  ::operations_research::CPIntegerMatrixProto* temp = integer_matrix_;
  integer_matrix_ = NULL;
  return temp;
}
inline void CPArgumentProto::set_allocated_integer_matrix(::operations_research::CPIntegerMatrixProto* integer_matrix) {
  delete integer_matrix_;
  integer_matrix_ = integer_matrix;
  if (integer_matrix) {
    set_has_integer_matrix();
  } else {
    clear_has_integer_matrix();
  }
}

// -------------------------------------------------------------------

// CPExtensionProto

// required int32 type_index = 1;
inline bool CPExtensionProto::has_type_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CPExtensionProto::set_has_type_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CPExtensionProto::clear_has_type_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CPExtensionProto::clear_type_index() {
  type_index_ = 0;
  clear_has_type_index();
}
inline ::google::protobuf::int32 CPExtensionProto::type_index() const {
  return type_index_;
}
inline void CPExtensionProto::set_type_index(::google::protobuf::int32 value) {
  set_has_type_index();
  type_index_ = value;
}

// repeated .operations_research.CPArgumentProto arguments = 2;
inline int CPExtensionProto::arguments_size() const {
  return arguments_.size();
}
inline void CPExtensionProto::clear_arguments() {
  arguments_.Clear();
}
inline const ::operations_research::CPArgumentProto& CPExtensionProto::arguments(int index) const {
  return arguments_.Get(index);
}
inline ::operations_research::CPArgumentProto* CPExtensionProto::mutable_arguments(int index) {
  return arguments_.Mutable(index);
}
inline ::operations_research::CPArgumentProto* CPExtensionProto::add_arguments() {
  return arguments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >&
CPExtensionProto::arguments() const {
  return arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >*
CPExtensionProto::mutable_arguments() {
  return &arguments_;
}

// -------------------------------------------------------------------

// CPIntegerExpressionProto

// required int32 index = 1;
inline bool CPIntegerExpressionProto::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CPIntegerExpressionProto::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CPIntegerExpressionProto::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CPIntegerExpressionProto::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 CPIntegerExpressionProto::index() const {
  return index_;
}
inline void CPIntegerExpressionProto::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// required int32 type_index = 2;
inline bool CPIntegerExpressionProto::has_type_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CPIntegerExpressionProto::set_has_type_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CPIntegerExpressionProto::clear_has_type_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CPIntegerExpressionProto::clear_type_index() {
  type_index_ = 0;
  clear_has_type_index();
}
inline ::google::protobuf::int32 CPIntegerExpressionProto::type_index() const {
  return type_index_;
}
inline void CPIntegerExpressionProto::set_type_index(::google::protobuf::int32 value) {
  set_has_type_index();
  type_index_ = value;
}

// optional string name = 3;
inline bool CPIntegerExpressionProto::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CPIntegerExpressionProto::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CPIntegerExpressionProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CPIntegerExpressionProto::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CPIntegerExpressionProto::name() const {
  return *name_;
}
inline void CPIntegerExpressionProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CPIntegerExpressionProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CPIntegerExpressionProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPIntegerExpressionProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CPIntegerExpressionProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CPIntegerExpressionProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .operations_research.CPArgumentProto arguments = 4;
inline int CPIntegerExpressionProto::arguments_size() const {
  return arguments_.size();
}
inline void CPIntegerExpressionProto::clear_arguments() {
  arguments_.Clear();
}
inline const ::operations_research::CPArgumentProto& CPIntegerExpressionProto::arguments(int index) const {
  return arguments_.Get(index);
}
inline ::operations_research::CPArgumentProto* CPIntegerExpressionProto::mutable_arguments(int index) {
  return arguments_.Mutable(index);
}
inline ::operations_research::CPArgumentProto* CPIntegerExpressionProto::add_arguments() {
  return arguments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >&
CPIntegerExpressionProto::arguments() const {
  return arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >*
CPIntegerExpressionProto::mutable_arguments() {
  return &arguments_;
}

// repeated .operations_research.CPExtensionProto extensions = 5;
inline int CPIntegerExpressionProto::extensions_size() const {
  return extensions_.size();
}
inline void CPIntegerExpressionProto::clear_extensions() {
  extensions_.Clear();
}
inline const ::operations_research::CPExtensionProto& CPIntegerExpressionProto::extensions(int index) const {
  return extensions_.Get(index);
}
inline ::operations_research::CPExtensionProto* CPIntegerExpressionProto::mutable_extensions(int index) {
  return extensions_.Mutable(index);
}
inline ::operations_research::CPExtensionProto* CPIntegerExpressionProto::add_extensions() {
  return extensions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPExtensionProto >&
CPIntegerExpressionProto::extensions() const {
  return extensions_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPExtensionProto >*
CPIntegerExpressionProto::mutable_extensions() {
  return &extensions_;
}

// -------------------------------------------------------------------

// CPIntervalVariableProto

// required int32 index = 1;
inline bool CPIntervalVariableProto::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CPIntervalVariableProto::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CPIntervalVariableProto::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CPIntervalVariableProto::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 CPIntervalVariableProto::index() const {
  return index_;
}
inline void CPIntervalVariableProto::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// required int32 type_index = 2;
inline bool CPIntervalVariableProto::has_type_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CPIntervalVariableProto::set_has_type_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CPIntervalVariableProto::clear_has_type_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CPIntervalVariableProto::clear_type_index() {
  type_index_ = 0;
  clear_has_type_index();
}
inline ::google::protobuf::int32 CPIntervalVariableProto::type_index() const {
  return type_index_;
}
inline void CPIntervalVariableProto::set_type_index(::google::protobuf::int32 value) {
  set_has_type_index();
  type_index_ = value;
}

// optional string name = 3;
inline bool CPIntervalVariableProto::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CPIntervalVariableProto::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CPIntervalVariableProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CPIntervalVariableProto::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CPIntervalVariableProto::name() const {
  return *name_;
}
inline void CPIntervalVariableProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CPIntervalVariableProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CPIntervalVariableProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPIntervalVariableProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CPIntervalVariableProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CPIntervalVariableProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .operations_research.CPArgumentProto arguments = 4;
inline int CPIntervalVariableProto::arguments_size() const {
  return arguments_.size();
}
inline void CPIntervalVariableProto::clear_arguments() {
  arguments_.Clear();
}
inline const ::operations_research::CPArgumentProto& CPIntervalVariableProto::arguments(int index) const {
  return arguments_.Get(index);
}
inline ::operations_research::CPArgumentProto* CPIntervalVariableProto::mutable_arguments(int index) {
  return arguments_.Mutable(index);
}
inline ::operations_research::CPArgumentProto* CPIntervalVariableProto::add_arguments() {
  return arguments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >&
CPIntervalVariableProto::arguments() const {
  return arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >*
CPIntervalVariableProto::mutable_arguments() {
  return &arguments_;
}

// -------------------------------------------------------------------

// CPSequenceVariableProto

// required int32 index = 1;
inline bool CPSequenceVariableProto::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CPSequenceVariableProto::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CPSequenceVariableProto::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CPSequenceVariableProto::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 CPSequenceVariableProto::index() const {
  return index_;
}
inline void CPSequenceVariableProto::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// required int32 type_index = 2;
inline bool CPSequenceVariableProto::has_type_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CPSequenceVariableProto::set_has_type_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CPSequenceVariableProto::clear_has_type_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CPSequenceVariableProto::clear_type_index() {
  type_index_ = 0;
  clear_has_type_index();
}
inline ::google::protobuf::int32 CPSequenceVariableProto::type_index() const {
  return type_index_;
}
inline void CPSequenceVariableProto::set_type_index(::google::protobuf::int32 value) {
  set_has_type_index();
  type_index_ = value;
}

// optional string name = 3;
inline bool CPSequenceVariableProto::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CPSequenceVariableProto::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CPSequenceVariableProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CPSequenceVariableProto::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CPSequenceVariableProto::name() const {
  return *name_;
}
inline void CPSequenceVariableProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CPSequenceVariableProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CPSequenceVariableProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPSequenceVariableProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CPSequenceVariableProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CPSequenceVariableProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .operations_research.CPArgumentProto arguments = 4;
inline int CPSequenceVariableProto::arguments_size() const {
  return arguments_.size();
}
inline void CPSequenceVariableProto::clear_arguments() {
  arguments_.Clear();
}
inline const ::operations_research::CPArgumentProto& CPSequenceVariableProto::arguments(int index) const {
  return arguments_.Get(index);
}
inline ::operations_research::CPArgumentProto* CPSequenceVariableProto::mutable_arguments(int index) {
  return arguments_.Mutable(index);
}
inline ::operations_research::CPArgumentProto* CPSequenceVariableProto::add_arguments() {
  return arguments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >&
CPSequenceVariableProto::arguments() const {
  return arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >*
CPSequenceVariableProto::mutable_arguments() {
  return &arguments_;
}

// -------------------------------------------------------------------

// CPConstraintProto

// required int32 index = 1;
inline bool CPConstraintProto::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CPConstraintProto::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CPConstraintProto::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CPConstraintProto::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 CPConstraintProto::index() const {
  return index_;
}
inline void CPConstraintProto::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// required int32 type_index = 2;
inline bool CPConstraintProto::has_type_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CPConstraintProto::set_has_type_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CPConstraintProto::clear_has_type_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CPConstraintProto::clear_type_index() {
  type_index_ = 0;
  clear_has_type_index();
}
inline ::google::protobuf::int32 CPConstraintProto::type_index() const {
  return type_index_;
}
inline void CPConstraintProto::set_type_index(::google::protobuf::int32 value) {
  set_has_type_index();
  type_index_ = value;
}

// optional string name = 3;
inline bool CPConstraintProto::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CPConstraintProto::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CPConstraintProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CPConstraintProto::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CPConstraintProto::name() const {
  return *name_;
}
inline void CPConstraintProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CPConstraintProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CPConstraintProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPConstraintProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CPConstraintProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CPConstraintProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .operations_research.CPArgumentProto arguments = 4;
inline int CPConstraintProto::arguments_size() const {
  return arguments_.size();
}
inline void CPConstraintProto::clear_arguments() {
  arguments_.Clear();
}
inline const ::operations_research::CPArgumentProto& CPConstraintProto::arguments(int index) const {
  return arguments_.Get(index);
}
inline ::operations_research::CPArgumentProto* CPConstraintProto::mutable_arguments(int index) {
  return arguments_.Mutable(index);
}
inline ::operations_research::CPArgumentProto* CPConstraintProto::add_arguments() {
  return arguments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >&
CPConstraintProto::arguments() const {
  return arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >*
CPConstraintProto::mutable_arguments() {
  return &arguments_;
}

// repeated .operations_research.CPExtensionProto extensions = 5;
inline int CPConstraintProto::extensions_size() const {
  return extensions_.size();
}
inline void CPConstraintProto::clear_extensions() {
  extensions_.Clear();
}
inline const ::operations_research::CPExtensionProto& CPConstraintProto::extensions(int index) const {
  return extensions_.Get(index);
}
inline ::operations_research::CPExtensionProto* CPConstraintProto::mutable_extensions(int index) {
  return extensions_.Mutable(index);
}
inline ::operations_research::CPExtensionProto* CPConstraintProto::add_extensions() {
  return extensions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPExtensionProto >&
CPConstraintProto::extensions() const {
  return extensions_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPExtensionProto >*
CPConstraintProto::mutable_extensions() {
  return &extensions_;
}

// -------------------------------------------------------------------

// CPObjectiveProto

// required bool maximize = 1;
inline bool CPObjectiveProto::has_maximize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CPObjectiveProto::set_has_maximize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CPObjectiveProto::clear_has_maximize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CPObjectiveProto::clear_maximize() {
  maximize_ = false;
  clear_has_maximize();
}
inline bool CPObjectiveProto::maximize() const {
  return maximize_;
}
inline void CPObjectiveProto::set_maximize(bool value) {
  set_has_maximize();
  maximize_ = value;
}

// required int64 step = 2;
inline bool CPObjectiveProto::has_step() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CPObjectiveProto::set_has_step() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CPObjectiveProto::clear_has_step() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CPObjectiveProto::clear_step() {
  step_ = GOOGLE_LONGLONG(0);
  clear_has_step();
}
inline ::google::protobuf::int64 CPObjectiveProto::step() const {
  return step_;
}
inline void CPObjectiveProto::set_step(::google::protobuf::int64 value) {
  set_has_step();
  step_ = value;
}

// required int32 objective_index = 3;
inline bool CPObjectiveProto::has_objective_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CPObjectiveProto::set_has_objective_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CPObjectiveProto::clear_has_objective_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CPObjectiveProto::clear_objective_index() {
  objective_index_ = 0;
  clear_has_objective_index();
}
inline ::google::protobuf::int32 CPObjectiveProto::objective_index() const {
  return objective_index_;
}
inline void CPObjectiveProto::set_objective_index(::google::protobuf::int32 value) {
  set_has_objective_index();
  objective_index_ = value;
}

// -------------------------------------------------------------------

// CPVariableGroup

// repeated .operations_research.CPArgumentProto arguments = 1;
inline int CPVariableGroup::arguments_size() const {
  return arguments_.size();
}
inline void CPVariableGroup::clear_arguments() {
  arguments_.Clear();
}
inline const ::operations_research::CPArgumentProto& CPVariableGroup::arguments(int index) const {
  return arguments_.Get(index);
}
inline ::operations_research::CPArgumentProto* CPVariableGroup::mutable_arguments(int index) {
  return arguments_.Mutable(index);
}
inline ::operations_research::CPArgumentProto* CPVariableGroup::add_arguments() {
  return arguments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >&
CPVariableGroup::arguments() const {
  return arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPArgumentProto >*
CPVariableGroup::mutable_arguments() {
  return &arguments_;
}

// optional string type = 2;
inline bool CPVariableGroup::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CPVariableGroup::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CPVariableGroup::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CPVariableGroup::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& CPVariableGroup::type() const {
  return *type_;
}
inline void CPVariableGroup::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void CPVariableGroup::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void CPVariableGroup::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPVariableGroup::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* CPVariableGroup::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CPVariableGroup::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CPModelProto

// required string model = 1;
inline bool CPModelProto::has_model() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CPModelProto::set_has_model() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CPModelProto::clear_has_model() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CPModelProto::clear_model() {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& CPModelProto::model() const {
  return *model_;
}
inline void CPModelProto::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void CPModelProto::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void CPModelProto::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPModelProto::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  return model_;
}
inline ::std::string* CPModelProto::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CPModelProto::set_allocated_model(::std::string* model) {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    delete model_;
  }
  if (model) {
    set_has_model();
    model_ = model;
  } else {
    clear_has_model();
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 version = 2;
inline bool CPModelProto::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CPModelProto::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CPModelProto::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CPModelProto::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 CPModelProto::version() const {
  return version_;
}
inline void CPModelProto::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// repeated string tags = 3;
inline int CPModelProto::tags_size() const {
  return tags_.size();
}
inline void CPModelProto::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& CPModelProto::tags(int index) const {
  return tags_.Get(index);
}
inline ::std::string* CPModelProto::mutable_tags(int index) {
  return tags_.Mutable(index);
}
inline void CPModelProto::set_tags(int index, const ::std::string& value) {
  tags_.Mutable(index)->assign(value);
}
inline void CPModelProto::set_tags(int index, const char* value) {
  tags_.Mutable(index)->assign(value);
}
inline void CPModelProto::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPModelProto::add_tags() {
  return tags_.Add();
}
inline void CPModelProto::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
}
inline void CPModelProto::add_tags(const char* value) {
  tags_.Add()->assign(value);
}
inline void CPModelProto::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CPModelProto::tags() const {
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CPModelProto::mutable_tags() {
  return &tags_;
}

// repeated .operations_research.CPIntegerExpressionProto expressions = 4;
inline int CPModelProto::expressions_size() const {
  return expressions_.size();
}
inline void CPModelProto::clear_expressions() {
  expressions_.Clear();
}
inline const ::operations_research::CPIntegerExpressionProto& CPModelProto::expressions(int index) const {
  return expressions_.Get(index);
}
inline ::operations_research::CPIntegerExpressionProto* CPModelProto::mutable_expressions(int index) {
  return expressions_.Mutable(index);
}
inline ::operations_research::CPIntegerExpressionProto* CPModelProto::add_expressions() {
  return expressions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPIntegerExpressionProto >&
CPModelProto::expressions() const {
  return expressions_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPIntegerExpressionProto >*
CPModelProto::mutable_expressions() {
  return &expressions_;
}

// repeated .operations_research.CPIntervalVariableProto intervals = 5;
inline int CPModelProto::intervals_size() const {
  return intervals_.size();
}
inline void CPModelProto::clear_intervals() {
  intervals_.Clear();
}
inline const ::operations_research::CPIntervalVariableProto& CPModelProto::intervals(int index) const {
  return intervals_.Get(index);
}
inline ::operations_research::CPIntervalVariableProto* CPModelProto::mutable_intervals(int index) {
  return intervals_.Mutable(index);
}
inline ::operations_research::CPIntervalVariableProto* CPModelProto::add_intervals() {
  return intervals_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPIntervalVariableProto >&
CPModelProto::intervals() const {
  return intervals_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPIntervalVariableProto >*
CPModelProto::mutable_intervals() {
  return &intervals_;
}

// repeated .operations_research.CPSequenceVariableProto sequences = 6;
inline int CPModelProto::sequences_size() const {
  return sequences_.size();
}
inline void CPModelProto::clear_sequences() {
  sequences_.Clear();
}
inline const ::operations_research::CPSequenceVariableProto& CPModelProto::sequences(int index) const {
  return sequences_.Get(index);
}
inline ::operations_research::CPSequenceVariableProto* CPModelProto::mutable_sequences(int index) {
  return sequences_.Mutable(index);
}
inline ::operations_research::CPSequenceVariableProto* CPModelProto::add_sequences() {
  return sequences_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPSequenceVariableProto >&
CPModelProto::sequences() const {
  return sequences_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPSequenceVariableProto >*
CPModelProto::mutable_sequences() {
  return &sequences_;
}

// repeated .operations_research.CPConstraintProto constraints = 7;
inline int CPModelProto::constraints_size() const {
  return constraints_.size();
}
inline void CPModelProto::clear_constraints() {
  constraints_.Clear();
}
inline const ::operations_research::CPConstraintProto& CPModelProto::constraints(int index) const {
  return constraints_.Get(index);
}
inline ::operations_research::CPConstraintProto* CPModelProto::mutable_constraints(int index) {
  return constraints_.Mutable(index);
}
inline ::operations_research::CPConstraintProto* CPModelProto::add_constraints() {
  return constraints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPConstraintProto >&
CPModelProto::constraints() const {
  return constraints_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPConstraintProto >*
CPModelProto::mutable_constraints() {
  return &constraints_;
}

// optional .operations_research.CPObjectiveProto objective = 8;
inline bool CPModelProto::has_objective() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CPModelProto::set_has_objective() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CPModelProto::clear_has_objective() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CPModelProto::clear_objective() {
  if (objective_ != NULL) objective_->::operations_research::CPObjectiveProto::Clear();
  clear_has_objective();
}
inline const ::operations_research::CPObjectiveProto& CPModelProto::objective() const {
  return objective_ != NULL ? *objective_ : *default_instance_->objective_;
}
inline ::operations_research::CPObjectiveProto* CPModelProto::mutable_objective() {
  set_has_objective();
  if (objective_ == NULL) objective_ = new ::operations_research::CPObjectiveProto;
  return objective_;
}
inline ::operations_research::CPObjectiveProto* CPModelProto::release_objective() {
  clear_has_objective();
  ::operations_research::CPObjectiveProto* temp = objective_;
  objective_ = NULL;
  return temp;
}
inline void CPModelProto::set_allocated_objective(::operations_research::CPObjectiveProto* objective) {
  delete objective_;
  objective_ = objective;
  if (objective) {
    set_has_objective();
  } else {
    clear_has_objective();
  }
}

// optional .operations_research.SearchLimitProto search_limit = 9;
inline bool CPModelProto::has_search_limit() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CPModelProto::set_has_search_limit() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CPModelProto::clear_has_search_limit() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CPModelProto::clear_search_limit() {
  if (search_limit_ != NULL) search_limit_->::operations_research::SearchLimitProto::Clear();
  clear_has_search_limit();
}
inline const ::operations_research::SearchLimitProto& CPModelProto::search_limit() const {
  return search_limit_ != NULL ? *search_limit_ : *default_instance_->search_limit_;
}
inline ::operations_research::SearchLimitProto* CPModelProto::mutable_search_limit() {
  set_has_search_limit();
  if (search_limit_ == NULL) search_limit_ = new ::operations_research::SearchLimitProto;
  return search_limit_;
}
inline ::operations_research::SearchLimitProto* CPModelProto::release_search_limit() {
  clear_has_search_limit();
  ::operations_research::SearchLimitProto* temp = search_limit_;
  search_limit_ = NULL;
  return temp;
}
inline void CPModelProto::set_allocated_search_limit(::operations_research::SearchLimitProto* search_limit) {
  delete search_limit_;
  search_limit_ = search_limit;
  if (search_limit) {
    set_has_search_limit();
  } else {
    clear_has_search_limit();
  }
}

// repeated .operations_research.CPVariableGroup variable_groups = 10;
inline int CPModelProto::variable_groups_size() const {
  return variable_groups_.size();
}
inline void CPModelProto::clear_variable_groups() {
  variable_groups_.Clear();
}
inline const ::operations_research::CPVariableGroup& CPModelProto::variable_groups(int index) const {
  return variable_groups_.Get(index);
}
inline ::operations_research::CPVariableGroup* CPModelProto::mutable_variable_groups(int index) {
  return variable_groups_.Mutable(index);
}
inline ::operations_research::CPVariableGroup* CPModelProto::add_variable_groups() {
  return variable_groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::CPVariableGroup >&
CPModelProto::variable_groups() const {
  return variable_groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::CPVariableGroup >*
CPModelProto::mutable_variable_groups() {
  return &variable_groups_;
}

// optional string license_text = 11;
inline bool CPModelProto::has_license_text() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CPModelProto::set_has_license_text() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CPModelProto::clear_has_license_text() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CPModelProto::clear_license_text() {
  if (license_text_ != &::google::protobuf::internal::kEmptyString) {
    license_text_->clear();
  }
  clear_has_license_text();
}
inline const ::std::string& CPModelProto::license_text() const {
  return *license_text_;
}
inline void CPModelProto::set_license_text(const ::std::string& value) {
  set_has_license_text();
  if (license_text_ == &::google::protobuf::internal::kEmptyString) {
    license_text_ = new ::std::string;
  }
  license_text_->assign(value);
}
inline void CPModelProto::set_license_text(const char* value) {
  set_has_license_text();
  if (license_text_ == &::google::protobuf::internal::kEmptyString) {
    license_text_ = new ::std::string;
  }
  license_text_->assign(value);
}
inline void CPModelProto::set_license_text(const char* value, size_t size) {
  set_has_license_text();
  if (license_text_ == &::google::protobuf::internal::kEmptyString) {
    license_text_ = new ::std::string;
  }
  license_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPModelProto::mutable_license_text() {
  set_has_license_text();
  if (license_text_ == &::google::protobuf::internal::kEmptyString) {
    license_text_ = new ::std::string;
  }
  return license_text_;
}
inline ::std::string* CPModelProto::release_license_text() {
  clear_has_license_text();
  if (license_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = license_text_;
    license_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CPModelProto::set_allocated_license_text(::std::string* license_text) {
  if (license_text_ != &::google::protobuf::internal::kEmptyString) {
    delete license_text_;
  }
  if (license_text) {
    set_has_license_text();
    license_text_ = license_text;
  } else {
    clear_has_license_text();
    license_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace operations_research

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_constraint_5fsolver_2fmodel_2eproto__INCLUDED
