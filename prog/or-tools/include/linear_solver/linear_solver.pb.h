// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: linear_solver/linear_solver.proto

#ifndef PROTOBUF_linear_5fsolver_2flinear_5fsolver_2eproto__INCLUDED
#define PROTOBUF_linear_5fsolver_2flinear_5fsolver_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace operations_research {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_linear_5fsolver_2flinear_5fsolver_2eproto();
void protobuf_AssignDesc_linear_5fsolver_2flinear_5fsolver_2eproto();
void protobuf_ShutdownFile_linear_5fsolver_2flinear_5fsolver_2eproto();

class MPVariableProto;
class MPTermProto;
class MPConstraintProto;
class MPModelProto;
class MPModelRequest;
class MPSolutionValue;
class MPSolutionResponse;

enum MPModelRequest_OptimizationProblemType {
  MPModelRequest_OptimizationProblemType_CLP_LINEAR_PROGRAMMING = 0,
  MPModelRequest_OptimizationProblemType_GLPK_LINEAR_PROGRAMMING = 1,
  MPModelRequest_OptimizationProblemType_SCIP_MIXED_INTEGER_PROGRAMMING = 3,
  MPModelRequest_OptimizationProblemType_GLPK_MIXED_INTEGER_PROGRAMMING = 4,
  MPModelRequest_OptimizationProblemType_CBC_MIXED_INTEGER_PROGRAMMING = 5
};
bool MPModelRequest_OptimizationProblemType_IsValid(int value);
const MPModelRequest_OptimizationProblemType MPModelRequest_OptimizationProblemType_OptimizationProblemType_MIN = MPModelRequest_OptimizationProblemType_CLP_LINEAR_PROGRAMMING;
const MPModelRequest_OptimizationProblemType MPModelRequest_OptimizationProblemType_OptimizationProblemType_MAX = MPModelRequest_OptimizationProblemType_CBC_MIXED_INTEGER_PROGRAMMING;
const int MPModelRequest_OptimizationProblemType_OptimizationProblemType_ARRAYSIZE = MPModelRequest_OptimizationProblemType_OptimizationProblemType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MPModelRequest_OptimizationProblemType_descriptor();
inline const ::std::string& MPModelRequest_OptimizationProblemType_Name(MPModelRequest_OptimizationProblemType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MPModelRequest_OptimizationProblemType_descriptor(), value);
}
inline bool MPModelRequest_OptimizationProblemType_Parse(
    const ::std::string& name, MPModelRequest_OptimizationProblemType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MPModelRequest_OptimizationProblemType>(
    MPModelRequest_OptimizationProblemType_descriptor(), name, value);
}
enum MPSolutionResponse_ResultStatus {
  MPSolutionResponse_ResultStatus_OPTIMAL = 0,
  MPSolutionResponse_ResultStatus_FEASIBLE = 1,
  MPSolutionResponse_ResultStatus_INFEASIBLE = 2,
  MPSolutionResponse_ResultStatus_UNBOUNDED = 3,
  MPSolutionResponse_ResultStatus_ABNORMAL = 4,
  MPSolutionResponse_ResultStatus_NOT_SOLVED = 5
};
bool MPSolutionResponse_ResultStatus_IsValid(int value);
const MPSolutionResponse_ResultStatus MPSolutionResponse_ResultStatus_ResultStatus_MIN = MPSolutionResponse_ResultStatus_OPTIMAL;
const MPSolutionResponse_ResultStatus MPSolutionResponse_ResultStatus_ResultStatus_MAX = MPSolutionResponse_ResultStatus_NOT_SOLVED;
const int MPSolutionResponse_ResultStatus_ResultStatus_ARRAYSIZE = MPSolutionResponse_ResultStatus_ResultStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* MPSolutionResponse_ResultStatus_descriptor();
inline const ::std::string& MPSolutionResponse_ResultStatus_Name(MPSolutionResponse_ResultStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    MPSolutionResponse_ResultStatus_descriptor(), value);
}
inline bool MPSolutionResponse_ResultStatus_Parse(
    const ::std::string& name, MPSolutionResponse_ResultStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MPSolutionResponse_ResultStatus>(
    MPSolutionResponse_ResultStatus_descriptor(), name, value);
}
// ===================================================================

class MPVariableProto : public ::google::protobuf::Message {
 public:
  MPVariableProto();
  virtual ~MPVariableProto();

  MPVariableProto(const MPVariableProto& from);

  inline MPVariableProto& operator=(const MPVariableProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MPVariableProto& default_instance();

  void Swap(MPVariableProto* other);

  // implements Message ----------------------------------------------

  MPVariableProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MPVariableProto& from);
  void MergeFrom(const MPVariableProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required double lb = 2;
  inline bool has_lb() const;
  inline void clear_lb();
  static const int kLbFieldNumber = 2;
  inline double lb() const;
  inline void set_lb(double value);

  // required double ub = 3;
  inline bool has_ub() const;
  inline void clear_ub();
  static const int kUbFieldNumber = 3;
  inline double ub() const;
  inline void set_ub(double value);

  // required bool integer = 4;
  inline bool has_integer() const;
  inline void clear_integer();
  static const int kIntegerFieldNumber = 4;
  inline bool integer() const;
  inline void set_integer(bool value);

  // @@protoc_insertion_point(class_scope:operations_research.MPVariableProto)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_lb();
  inline void clear_has_lb();
  inline void set_has_ub();
  inline void clear_has_ub();
  inline void set_has_integer();
  inline void clear_has_integer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  double lb_;
  double ub_;
  bool integer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_linear_5fsolver_2flinear_5fsolver_2eproto();
  friend void protobuf_AssignDesc_linear_5fsolver_2flinear_5fsolver_2eproto();
  friend void protobuf_ShutdownFile_linear_5fsolver_2flinear_5fsolver_2eproto();

  void InitAsDefaultInstance();
  static MPVariableProto* default_instance_;
};
// -------------------------------------------------------------------

class MPTermProto : public ::google::protobuf::Message {
 public:
  MPTermProto();
  virtual ~MPTermProto();

  MPTermProto(const MPTermProto& from);

  inline MPTermProto& operator=(const MPTermProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MPTermProto& default_instance();

  void Swap(MPTermProto* other);

  // implements Message ----------------------------------------------

  MPTermProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MPTermProto& from);
  void MergeFrom(const MPTermProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string variable_id = 1;
  inline bool has_variable_id() const;
  inline void clear_variable_id();
  static const int kVariableIdFieldNumber = 1;
  inline const ::std::string& variable_id() const;
  inline void set_variable_id(const ::std::string& value);
  inline void set_variable_id(const char* value);
  inline void set_variable_id(const char* value, size_t size);
  inline ::std::string* mutable_variable_id();
  inline ::std::string* release_variable_id();
  inline void set_allocated_variable_id(::std::string* variable_id);

  // required double coefficient = 2;
  inline bool has_coefficient() const;
  inline void clear_coefficient();
  static const int kCoefficientFieldNumber = 2;
  inline double coefficient() const;
  inline void set_coefficient(double value);

  // @@protoc_insertion_point(class_scope:operations_research.MPTermProto)
 private:
  inline void set_has_variable_id();
  inline void clear_has_variable_id();
  inline void set_has_coefficient();
  inline void clear_has_coefficient();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* variable_id_;
  double coefficient_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_linear_5fsolver_2flinear_5fsolver_2eproto();
  friend void protobuf_AssignDesc_linear_5fsolver_2flinear_5fsolver_2eproto();
  friend void protobuf_ShutdownFile_linear_5fsolver_2flinear_5fsolver_2eproto();

  void InitAsDefaultInstance();
  static MPTermProto* default_instance_;
};
// -------------------------------------------------------------------

class MPConstraintProto : public ::google::protobuf::Message {
 public:
  MPConstraintProto();
  virtual ~MPConstraintProto();

  MPConstraintProto(const MPConstraintProto& from);

  inline MPConstraintProto& operator=(const MPConstraintProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MPConstraintProto& default_instance();

  void Swap(MPConstraintProto* other);

  // implements Message ----------------------------------------------

  MPConstraintProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MPConstraintProto& from);
  void MergeFrom(const MPConstraintProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double lb = 1;
  inline bool has_lb() const;
  inline void clear_lb();
  static const int kLbFieldNumber = 1;
  inline double lb() const;
  inline void set_lb(double value);

  // required double ub = 2;
  inline bool has_ub() const;
  inline void clear_ub();
  static const int kUbFieldNumber = 2;
  inline double ub() const;
  inline void set_ub(double value);

  // repeated .operations_research.MPTermProto terms = 3;
  inline int terms_size() const;
  inline void clear_terms();
  static const int kTermsFieldNumber = 3;
  inline const ::operations_research::MPTermProto& terms(int index) const;
  inline ::operations_research::MPTermProto* mutable_terms(int index);
  inline ::operations_research::MPTermProto* add_terms();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::MPTermProto >&
      terms() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::MPTermProto >*
      mutable_terms();

  // optional string id = 4;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 4;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:operations_research.MPConstraintProto)
 private:
  inline void set_has_lb();
  inline void clear_has_lb();
  inline void set_has_ub();
  inline void clear_has_ub();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double lb_;
  double ub_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::MPTermProto > terms_;
  ::std::string* id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_linear_5fsolver_2flinear_5fsolver_2eproto();
  friend void protobuf_AssignDesc_linear_5fsolver_2flinear_5fsolver_2eproto();
  friend void protobuf_ShutdownFile_linear_5fsolver_2flinear_5fsolver_2eproto();

  void InitAsDefaultInstance();
  static MPConstraintProto* default_instance_;
};
// -------------------------------------------------------------------

class MPModelProto : public ::google::protobuf::Message {
 public:
  MPModelProto();
  virtual ~MPModelProto();

  MPModelProto(const MPModelProto& from);

  inline MPModelProto& operator=(const MPModelProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MPModelProto& default_instance();

  void Swap(MPModelProto* other);

  // implements Message ----------------------------------------------

  MPModelProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MPModelProto& from);
  void MergeFrom(const MPModelProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .operations_research.MPVariableProto variables = 1;
  inline int variables_size() const;
  inline void clear_variables();
  static const int kVariablesFieldNumber = 1;
  inline const ::operations_research::MPVariableProto& variables(int index) const;
  inline ::operations_research::MPVariableProto* mutable_variables(int index);
  inline ::operations_research::MPVariableProto* add_variables();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::MPVariableProto >&
      variables() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::MPVariableProto >*
      mutable_variables();

  // required bool maximize = 2;
  inline bool has_maximize() const;
  inline void clear_maximize();
  static const int kMaximizeFieldNumber = 2;
  inline bool maximize() const;
  inline void set_maximize(bool value);

  // repeated .operations_research.MPTermProto objective_terms = 3;
  inline int objective_terms_size() const;
  inline void clear_objective_terms();
  static const int kObjectiveTermsFieldNumber = 3;
  inline const ::operations_research::MPTermProto& objective_terms(int index) const;
  inline ::operations_research::MPTermProto* mutable_objective_terms(int index);
  inline ::operations_research::MPTermProto* add_objective_terms();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::MPTermProto >&
      objective_terms() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::MPTermProto >*
      mutable_objective_terms();

  // repeated .operations_research.MPConstraintProto constraints = 7;
  inline int constraints_size() const;
  inline void clear_constraints();
  static const int kConstraintsFieldNumber = 7;
  inline const ::operations_research::MPConstraintProto& constraints(int index) const;
  inline ::operations_research::MPConstraintProto* mutable_constraints(int index);
  inline ::operations_research::MPConstraintProto* add_constraints();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::MPConstraintProto >&
      constraints() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::MPConstraintProto >*
      mutable_constraints();

  // optional string name = 8;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 8;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional double objective_offset = 9;
  inline bool has_objective_offset() const;
  inline void clear_objective_offset();
  static const int kObjectiveOffsetFieldNumber = 9;
  inline double objective_offset() const;
  inline void set_objective_offset(double value);

  // @@protoc_insertion_point(class_scope:operations_research.MPModelProto)
 private:
  inline void set_has_maximize();
  inline void clear_has_maximize();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_objective_offset();
  inline void clear_has_objective_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::operations_research::MPVariableProto > variables_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::MPTermProto > objective_terms_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::MPConstraintProto > constraints_;
  ::std::string* name_;
  double objective_offset_;
  bool maximize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_linear_5fsolver_2flinear_5fsolver_2eproto();
  friend void protobuf_AssignDesc_linear_5fsolver_2flinear_5fsolver_2eproto();
  friend void protobuf_ShutdownFile_linear_5fsolver_2flinear_5fsolver_2eproto();

  void InitAsDefaultInstance();
  static MPModelProto* default_instance_;
};
// -------------------------------------------------------------------

class MPModelRequest : public ::google::protobuf::Message {
 public:
  MPModelRequest();
  virtual ~MPModelRequest();

  MPModelRequest(const MPModelRequest& from);

  inline MPModelRequest& operator=(const MPModelRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MPModelRequest& default_instance();

  void Swap(MPModelRequest* other);

  // implements Message ----------------------------------------------

  MPModelRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MPModelRequest& from);
  void MergeFrom(const MPModelRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MPModelRequest_OptimizationProblemType OptimizationProblemType;
  static const OptimizationProblemType CLP_LINEAR_PROGRAMMING = MPModelRequest_OptimizationProblemType_CLP_LINEAR_PROGRAMMING;
  static const OptimizationProblemType GLPK_LINEAR_PROGRAMMING = MPModelRequest_OptimizationProblemType_GLPK_LINEAR_PROGRAMMING;
  static const OptimizationProblemType SCIP_MIXED_INTEGER_PROGRAMMING = MPModelRequest_OptimizationProblemType_SCIP_MIXED_INTEGER_PROGRAMMING;
  static const OptimizationProblemType GLPK_MIXED_INTEGER_PROGRAMMING = MPModelRequest_OptimizationProblemType_GLPK_MIXED_INTEGER_PROGRAMMING;
  static const OptimizationProblemType CBC_MIXED_INTEGER_PROGRAMMING = MPModelRequest_OptimizationProblemType_CBC_MIXED_INTEGER_PROGRAMMING;
  static inline bool OptimizationProblemType_IsValid(int value) {
    return MPModelRequest_OptimizationProblemType_IsValid(value);
  }
  static const OptimizationProblemType OptimizationProblemType_MIN =
    MPModelRequest_OptimizationProblemType_OptimizationProblemType_MIN;
  static const OptimizationProblemType OptimizationProblemType_MAX =
    MPModelRequest_OptimizationProblemType_OptimizationProblemType_MAX;
  static const int OptimizationProblemType_ARRAYSIZE =
    MPModelRequest_OptimizationProblemType_OptimizationProblemType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OptimizationProblemType_descriptor() {
    return MPModelRequest_OptimizationProblemType_descriptor();
  }
  static inline const ::std::string& OptimizationProblemType_Name(OptimizationProblemType value) {
    return MPModelRequest_OptimizationProblemType_Name(value);
  }
  static inline bool OptimizationProblemType_Parse(const ::std::string& name,
      OptimizationProblemType* value) {
    return MPModelRequest_OptimizationProblemType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .operations_research.MPModelProto model = 1;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 1;
  inline const ::operations_research::MPModelProto& model() const;
  inline ::operations_research::MPModelProto* mutable_model();
  inline ::operations_research::MPModelProto* release_model();
  inline void set_allocated_model(::operations_research::MPModelProto* model);

  // required .operations_research.MPModelRequest.OptimizationProblemType problem_type = 2;
  inline bool has_problem_type() const;
  inline void clear_problem_type();
  static const int kProblemTypeFieldNumber = 2;
  inline ::operations_research::MPModelRequest_OptimizationProblemType problem_type() const;
  inline void set_problem_type(::operations_research::MPModelRequest_OptimizationProblemType value);

  // optional int32 time_limit_ms = 3;
  inline bool has_time_limit_ms() const;
  inline void clear_time_limit_ms();
  static const int kTimeLimitMsFieldNumber = 3;
  inline ::google::protobuf::int32 time_limit_ms() const;
  inline void set_time_limit_ms(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:operations_research.MPModelRequest)
 private:
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_problem_type();
  inline void clear_has_problem_type();
  inline void set_has_time_limit_ms();
  inline void clear_has_time_limit_ms();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::operations_research::MPModelProto* model_;
  int problem_type_;
  ::google::protobuf::int32 time_limit_ms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_linear_5fsolver_2flinear_5fsolver_2eproto();
  friend void protobuf_AssignDesc_linear_5fsolver_2flinear_5fsolver_2eproto();
  friend void protobuf_ShutdownFile_linear_5fsolver_2flinear_5fsolver_2eproto();

  void InitAsDefaultInstance();
  static MPModelRequest* default_instance_;
};
// -------------------------------------------------------------------

class MPSolutionValue : public ::google::protobuf::Message {
 public:
  MPSolutionValue();
  virtual ~MPSolutionValue();

  MPSolutionValue(const MPSolutionValue& from);

  inline MPSolutionValue& operator=(const MPSolutionValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MPSolutionValue& default_instance();

  void Swap(MPSolutionValue* other);

  // implements Message ----------------------------------------------

  MPSolutionValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MPSolutionValue& from);
  void MergeFrom(const MPSolutionValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string variable_id = 1;
  inline bool has_variable_id() const;
  inline void clear_variable_id();
  static const int kVariableIdFieldNumber = 1;
  inline const ::std::string& variable_id() const;
  inline void set_variable_id(const ::std::string& value);
  inline void set_variable_id(const char* value);
  inline void set_variable_id(const char* value, size_t size);
  inline ::std::string* mutable_variable_id();
  inline ::std::string* release_variable_id();
  inline void set_allocated_variable_id(::std::string* variable_id);

  // required double value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline double value() const;
  inline void set_value(double value);

  // @@protoc_insertion_point(class_scope:operations_research.MPSolutionValue)
 private:
  inline void set_has_variable_id();
  inline void clear_has_variable_id();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* variable_id_;
  double value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_linear_5fsolver_2flinear_5fsolver_2eproto();
  friend void protobuf_AssignDesc_linear_5fsolver_2flinear_5fsolver_2eproto();
  friend void protobuf_ShutdownFile_linear_5fsolver_2flinear_5fsolver_2eproto();

  void InitAsDefaultInstance();
  static MPSolutionValue* default_instance_;
};
// -------------------------------------------------------------------

class MPSolutionResponse : public ::google::protobuf::Message {
 public:
  MPSolutionResponse();
  virtual ~MPSolutionResponse();

  MPSolutionResponse(const MPSolutionResponse& from);

  inline MPSolutionResponse& operator=(const MPSolutionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MPSolutionResponse& default_instance();

  void Swap(MPSolutionResponse* other);

  // implements Message ----------------------------------------------

  MPSolutionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MPSolutionResponse& from);
  void MergeFrom(const MPSolutionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MPSolutionResponse_ResultStatus ResultStatus;
  static const ResultStatus OPTIMAL = MPSolutionResponse_ResultStatus_OPTIMAL;
  static const ResultStatus FEASIBLE = MPSolutionResponse_ResultStatus_FEASIBLE;
  static const ResultStatus INFEASIBLE = MPSolutionResponse_ResultStatus_INFEASIBLE;
  static const ResultStatus UNBOUNDED = MPSolutionResponse_ResultStatus_UNBOUNDED;
  static const ResultStatus ABNORMAL = MPSolutionResponse_ResultStatus_ABNORMAL;
  static const ResultStatus NOT_SOLVED = MPSolutionResponse_ResultStatus_NOT_SOLVED;
  static inline bool ResultStatus_IsValid(int value) {
    return MPSolutionResponse_ResultStatus_IsValid(value);
  }
  static const ResultStatus ResultStatus_MIN =
    MPSolutionResponse_ResultStatus_ResultStatus_MIN;
  static const ResultStatus ResultStatus_MAX =
    MPSolutionResponse_ResultStatus_ResultStatus_MAX;
  static const int ResultStatus_ARRAYSIZE =
    MPSolutionResponse_ResultStatus_ResultStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResultStatus_descriptor() {
    return MPSolutionResponse_ResultStatus_descriptor();
  }
  static inline const ::std::string& ResultStatus_Name(ResultStatus value) {
    return MPSolutionResponse_ResultStatus_Name(value);
  }
  static inline bool ResultStatus_Parse(const ::std::string& name,
      ResultStatus* value) {
    return MPSolutionResponse_ResultStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .operations_research.MPSolutionResponse.ResultStatus result_status = 1;
  inline bool has_result_status() const;
  inline void clear_result_status();
  static const int kResultStatusFieldNumber = 1;
  inline ::operations_research::MPSolutionResponse_ResultStatus result_status() const;
  inline void set_result_status(::operations_research::MPSolutionResponse_ResultStatus value);

  // optional double objective_value = 2;
  inline bool has_objective_value() const;
  inline void clear_objective_value();
  static const int kObjectiveValueFieldNumber = 2;
  inline double objective_value() const;
  inline void set_objective_value(double value);

  // repeated .operations_research.MPSolutionValue solution_values = 3;
  inline int solution_values_size() const;
  inline void clear_solution_values();
  static const int kSolutionValuesFieldNumber = 3;
  inline const ::operations_research::MPSolutionValue& solution_values(int index) const;
  inline ::operations_research::MPSolutionValue* mutable_solution_values(int index);
  inline ::operations_research::MPSolutionValue* add_solution_values();
  inline const ::google::protobuf::RepeatedPtrField< ::operations_research::MPSolutionValue >&
      solution_values() const;
  inline ::google::protobuf::RepeatedPtrField< ::operations_research::MPSolutionValue >*
      mutable_solution_values();

  // @@protoc_insertion_point(class_scope:operations_research.MPSolutionResponse)
 private:
  inline void set_has_result_status();
  inline void clear_has_result_status();
  inline void set_has_objective_value();
  inline void clear_has_objective_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double objective_value_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::MPSolutionValue > solution_values_;
  int result_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_linear_5fsolver_2flinear_5fsolver_2eproto();
  friend void protobuf_AssignDesc_linear_5fsolver_2flinear_5fsolver_2eproto();
  friend void protobuf_ShutdownFile_linear_5fsolver_2flinear_5fsolver_2eproto();

  void InitAsDefaultInstance();
  static MPSolutionResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// MPVariableProto

// required string id = 1;
inline bool MPVariableProto::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MPVariableProto::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MPVariableProto::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MPVariableProto::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& MPVariableProto::id() const {
  return *id_;
}
inline void MPVariableProto::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void MPVariableProto::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void MPVariableProto::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MPVariableProto::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* MPVariableProto::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MPVariableProto::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double lb = 2;
inline bool MPVariableProto::has_lb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MPVariableProto::set_has_lb() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MPVariableProto::clear_has_lb() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MPVariableProto::clear_lb() {
  lb_ = 0;
  clear_has_lb();
}
inline double MPVariableProto::lb() const {
  return lb_;
}
inline void MPVariableProto::set_lb(double value) {
  set_has_lb();
  lb_ = value;
}

// required double ub = 3;
inline bool MPVariableProto::has_ub() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MPVariableProto::set_has_ub() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MPVariableProto::clear_has_ub() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MPVariableProto::clear_ub() {
  ub_ = 0;
  clear_has_ub();
}
inline double MPVariableProto::ub() const {
  return ub_;
}
inline void MPVariableProto::set_ub(double value) {
  set_has_ub();
  ub_ = value;
}

// required bool integer = 4;
inline bool MPVariableProto::has_integer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MPVariableProto::set_has_integer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MPVariableProto::clear_has_integer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MPVariableProto::clear_integer() {
  integer_ = false;
  clear_has_integer();
}
inline bool MPVariableProto::integer() const {
  return integer_;
}
inline void MPVariableProto::set_integer(bool value) {
  set_has_integer();
  integer_ = value;
}

// -------------------------------------------------------------------

// MPTermProto

// required string variable_id = 1;
inline bool MPTermProto::has_variable_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MPTermProto::set_has_variable_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MPTermProto::clear_has_variable_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MPTermProto::clear_variable_id() {
  if (variable_id_ != &::google::protobuf::internal::kEmptyString) {
    variable_id_->clear();
  }
  clear_has_variable_id();
}
inline const ::std::string& MPTermProto::variable_id() const {
  return *variable_id_;
}
inline void MPTermProto::set_variable_id(const ::std::string& value) {
  set_has_variable_id();
  if (variable_id_ == &::google::protobuf::internal::kEmptyString) {
    variable_id_ = new ::std::string;
  }
  variable_id_->assign(value);
}
inline void MPTermProto::set_variable_id(const char* value) {
  set_has_variable_id();
  if (variable_id_ == &::google::protobuf::internal::kEmptyString) {
    variable_id_ = new ::std::string;
  }
  variable_id_->assign(value);
}
inline void MPTermProto::set_variable_id(const char* value, size_t size) {
  set_has_variable_id();
  if (variable_id_ == &::google::protobuf::internal::kEmptyString) {
    variable_id_ = new ::std::string;
  }
  variable_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MPTermProto::mutable_variable_id() {
  set_has_variable_id();
  if (variable_id_ == &::google::protobuf::internal::kEmptyString) {
    variable_id_ = new ::std::string;
  }
  return variable_id_;
}
inline ::std::string* MPTermProto::release_variable_id() {
  clear_has_variable_id();
  if (variable_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = variable_id_;
    variable_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MPTermProto::set_allocated_variable_id(::std::string* variable_id) {
  if (variable_id_ != &::google::protobuf::internal::kEmptyString) {
    delete variable_id_;
  }
  if (variable_id) {
    set_has_variable_id();
    variable_id_ = variable_id;
  } else {
    clear_has_variable_id();
    variable_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double coefficient = 2;
inline bool MPTermProto::has_coefficient() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MPTermProto::set_has_coefficient() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MPTermProto::clear_has_coefficient() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MPTermProto::clear_coefficient() {
  coefficient_ = 0;
  clear_has_coefficient();
}
inline double MPTermProto::coefficient() const {
  return coefficient_;
}
inline void MPTermProto::set_coefficient(double value) {
  set_has_coefficient();
  coefficient_ = value;
}

// -------------------------------------------------------------------

// MPConstraintProto

// required double lb = 1;
inline bool MPConstraintProto::has_lb() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MPConstraintProto::set_has_lb() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MPConstraintProto::clear_has_lb() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MPConstraintProto::clear_lb() {
  lb_ = 0;
  clear_has_lb();
}
inline double MPConstraintProto::lb() const {
  return lb_;
}
inline void MPConstraintProto::set_lb(double value) {
  set_has_lb();
  lb_ = value;
}

// required double ub = 2;
inline bool MPConstraintProto::has_ub() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MPConstraintProto::set_has_ub() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MPConstraintProto::clear_has_ub() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MPConstraintProto::clear_ub() {
  ub_ = 0;
  clear_has_ub();
}
inline double MPConstraintProto::ub() const {
  return ub_;
}
inline void MPConstraintProto::set_ub(double value) {
  set_has_ub();
  ub_ = value;
}

// repeated .operations_research.MPTermProto terms = 3;
inline int MPConstraintProto::terms_size() const {
  return terms_.size();
}
inline void MPConstraintProto::clear_terms() {
  terms_.Clear();
}
inline const ::operations_research::MPTermProto& MPConstraintProto::terms(int index) const {
  return terms_.Get(index);
}
inline ::operations_research::MPTermProto* MPConstraintProto::mutable_terms(int index) {
  return terms_.Mutable(index);
}
inline ::operations_research::MPTermProto* MPConstraintProto::add_terms() {
  return terms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::MPTermProto >&
MPConstraintProto::terms() const {
  return terms_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::MPTermProto >*
MPConstraintProto::mutable_terms() {
  return &terms_;
}

// optional string id = 4;
inline bool MPConstraintProto::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MPConstraintProto::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MPConstraintProto::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MPConstraintProto::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& MPConstraintProto::id() const {
  return *id_;
}
inline void MPConstraintProto::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void MPConstraintProto::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void MPConstraintProto::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MPConstraintProto::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* MPConstraintProto::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MPConstraintProto::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MPModelProto

// repeated .operations_research.MPVariableProto variables = 1;
inline int MPModelProto::variables_size() const {
  return variables_.size();
}
inline void MPModelProto::clear_variables() {
  variables_.Clear();
}
inline const ::operations_research::MPVariableProto& MPModelProto::variables(int index) const {
  return variables_.Get(index);
}
inline ::operations_research::MPVariableProto* MPModelProto::mutable_variables(int index) {
  return variables_.Mutable(index);
}
inline ::operations_research::MPVariableProto* MPModelProto::add_variables() {
  return variables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::MPVariableProto >&
MPModelProto::variables() const {
  return variables_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::MPVariableProto >*
MPModelProto::mutable_variables() {
  return &variables_;
}

// required bool maximize = 2;
inline bool MPModelProto::has_maximize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MPModelProto::set_has_maximize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MPModelProto::clear_has_maximize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MPModelProto::clear_maximize() {
  maximize_ = false;
  clear_has_maximize();
}
inline bool MPModelProto::maximize() const {
  return maximize_;
}
inline void MPModelProto::set_maximize(bool value) {
  set_has_maximize();
  maximize_ = value;
}

// repeated .operations_research.MPTermProto objective_terms = 3;
inline int MPModelProto::objective_terms_size() const {
  return objective_terms_.size();
}
inline void MPModelProto::clear_objective_terms() {
  objective_terms_.Clear();
}
inline const ::operations_research::MPTermProto& MPModelProto::objective_terms(int index) const {
  return objective_terms_.Get(index);
}
inline ::operations_research::MPTermProto* MPModelProto::mutable_objective_terms(int index) {
  return objective_terms_.Mutable(index);
}
inline ::operations_research::MPTermProto* MPModelProto::add_objective_terms() {
  return objective_terms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::MPTermProto >&
MPModelProto::objective_terms() const {
  return objective_terms_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::MPTermProto >*
MPModelProto::mutable_objective_terms() {
  return &objective_terms_;
}

// repeated .operations_research.MPConstraintProto constraints = 7;
inline int MPModelProto::constraints_size() const {
  return constraints_.size();
}
inline void MPModelProto::clear_constraints() {
  constraints_.Clear();
}
inline const ::operations_research::MPConstraintProto& MPModelProto::constraints(int index) const {
  return constraints_.Get(index);
}
inline ::operations_research::MPConstraintProto* MPModelProto::mutable_constraints(int index) {
  return constraints_.Mutable(index);
}
inline ::operations_research::MPConstraintProto* MPModelProto::add_constraints() {
  return constraints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::MPConstraintProto >&
MPModelProto::constraints() const {
  return constraints_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::MPConstraintProto >*
MPModelProto::mutable_constraints() {
  return &constraints_;
}

// optional string name = 8;
inline bool MPModelProto::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MPModelProto::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MPModelProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MPModelProto::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MPModelProto::name() const {
  return *name_;
}
inline void MPModelProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MPModelProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MPModelProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MPModelProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MPModelProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MPModelProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double objective_offset = 9;
inline bool MPModelProto::has_objective_offset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MPModelProto::set_has_objective_offset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MPModelProto::clear_has_objective_offset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MPModelProto::clear_objective_offset() {
  objective_offset_ = 0;
  clear_has_objective_offset();
}
inline double MPModelProto::objective_offset() const {
  return objective_offset_;
}
inline void MPModelProto::set_objective_offset(double value) {
  set_has_objective_offset();
  objective_offset_ = value;
}

// -------------------------------------------------------------------

// MPModelRequest

// required .operations_research.MPModelProto model = 1;
inline bool MPModelRequest::has_model() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MPModelRequest::set_has_model() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MPModelRequest::clear_has_model() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MPModelRequest::clear_model() {
  if (model_ != NULL) model_->::operations_research::MPModelProto::Clear();
  clear_has_model();
}
inline const ::operations_research::MPModelProto& MPModelRequest::model() const {
  return model_ != NULL ? *model_ : *default_instance_->model_;
}
inline ::operations_research::MPModelProto* MPModelRequest::mutable_model() {
  set_has_model();
  if (model_ == NULL) model_ = new ::operations_research::MPModelProto;
  return model_;
}
inline ::operations_research::MPModelProto* MPModelRequest::release_model() {
  clear_has_model();
  ::operations_research::MPModelProto* temp = model_;
  model_ = NULL;
  return temp;
}
inline void MPModelRequest::set_allocated_model(::operations_research::MPModelProto* model) {
  delete model_;
  model_ = model;
  if (model) {
    set_has_model();
  } else {
    clear_has_model();
  }
}

// required .operations_research.MPModelRequest.OptimizationProblemType problem_type = 2;
inline bool MPModelRequest::has_problem_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MPModelRequest::set_has_problem_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MPModelRequest::clear_has_problem_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MPModelRequest::clear_problem_type() {
  problem_type_ = 0;
  clear_has_problem_type();
}
inline ::operations_research::MPModelRequest_OptimizationProblemType MPModelRequest::problem_type() const {
  return static_cast< ::operations_research::MPModelRequest_OptimizationProblemType >(problem_type_);
}
inline void MPModelRequest::set_problem_type(::operations_research::MPModelRequest_OptimizationProblemType value) {
  assert(::operations_research::MPModelRequest_OptimizationProblemType_IsValid(value));
  set_has_problem_type();
  problem_type_ = value;
}

// optional int32 time_limit_ms = 3;
inline bool MPModelRequest::has_time_limit_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MPModelRequest::set_has_time_limit_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MPModelRequest::clear_has_time_limit_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MPModelRequest::clear_time_limit_ms() {
  time_limit_ms_ = 0;
  clear_has_time_limit_ms();
}
inline ::google::protobuf::int32 MPModelRequest::time_limit_ms() const {
  return time_limit_ms_;
}
inline void MPModelRequest::set_time_limit_ms(::google::protobuf::int32 value) {
  set_has_time_limit_ms();
  time_limit_ms_ = value;
}

// -------------------------------------------------------------------

// MPSolutionValue

// required string variable_id = 1;
inline bool MPSolutionValue::has_variable_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MPSolutionValue::set_has_variable_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MPSolutionValue::clear_has_variable_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MPSolutionValue::clear_variable_id() {
  if (variable_id_ != &::google::protobuf::internal::kEmptyString) {
    variable_id_->clear();
  }
  clear_has_variable_id();
}
inline const ::std::string& MPSolutionValue::variable_id() const {
  return *variable_id_;
}
inline void MPSolutionValue::set_variable_id(const ::std::string& value) {
  set_has_variable_id();
  if (variable_id_ == &::google::protobuf::internal::kEmptyString) {
    variable_id_ = new ::std::string;
  }
  variable_id_->assign(value);
}
inline void MPSolutionValue::set_variable_id(const char* value) {
  set_has_variable_id();
  if (variable_id_ == &::google::protobuf::internal::kEmptyString) {
    variable_id_ = new ::std::string;
  }
  variable_id_->assign(value);
}
inline void MPSolutionValue::set_variable_id(const char* value, size_t size) {
  set_has_variable_id();
  if (variable_id_ == &::google::protobuf::internal::kEmptyString) {
    variable_id_ = new ::std::string;
  }
  variable_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MPSolutionValue::mutable_variable_id() {
  set_has_variable_id();
  if (variable_id_ == &::google::protobuf::internal::kEmptyString) {
    variable_id_ = new ::std::string;
  }
  return variable_id_;
}
inline ::std::string* MPSolutionValue::release_variable_id() {
  clear_has_variable_id();
  if (variable_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = variable_id_;
    variable_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MPSolutionValue::set_allocated_variable_id(::std::string* variable_id) {
  if (variable_id_ != &::google::protobuf::internal::kEmptyString) {
    delete variable_id_;
  }
  if (variable_id) {
    set_has_variable_id();
    variable_id_ = variable_id;
  } else {
    clear_has_variable_id();
    variable_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double value = 2;
inline bool MPSolutionValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MPSolutionValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MPSolutionValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MPSolutionValue::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double MPSolutionValue::value() const {
  return value_;
}
inline void MPSolutionValue::set_value(double value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// MPSolutionResponse

// required .operations_research.MPSolutionResponse.ResultStatus result_status = 1;
inline bool MPSolutionResponse::has_result_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MPSolutionResponse::set_has_result_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MPSolutionResponse::clear_has_result_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MPSolutionResponse::clear_result_status() {
  result_status_ = 0;
  clear_has_result_status();
}
inline ::operations_research::MPSolutionResponse_ResultStatus MPSolutionResponse::result_status() const {
  return static_cast< ::operations_research::MPSolutionResponse_ResultStatus >(result_status_);
}
inline void MPSolutionResponse::set_result_status(::operations_research::MPSolutionResponse_ResultStatus value) {
  assert(::operations_research::MPSolutionResponse_ResultStatus_IsValid(value));
  set_has_result_status();
  result_status_ = value;
}

// optional double objective_value = 2;
inline bool MPSolutionResponse::has_objective_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MPSolutionResponse::set_has_objective_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MPSolutionResponse::clear_has_objective_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MPSolutionResponse::clear_objective_value() {
  objective_value_ = 0;
  clear_has_objective_value();
}
inline double MPSolutionResponse::objective_value() const {
  return objective_value_;
}
inline void MPSolutionResponse::set_objective_value(double value) {
  set_has_objective_value();
  objective_value_ = value;
}

// repeated .operations_research.MPSolutionValue solution_values = 3;
inline int MPSolutionResponse::solution_values_size() const {
  return solution_values_.size();
}
inline void MPSolutionResponse::clear_solution_values() {
  solution_values_.Clear();
}
inline const ::operations_research::MPSolutionValue& MPSolutionResponse::solution_values(int index) const {
  return solution_values_.Get(index);
}
inline ::operations_research::MPSolutionValue* MPSolutionResponse::mutable_solution_values(int index) {
  return solution_values_.Mutable(index);
}
inline ::operations_research::MPSolutionValue* MPSolutionResponse::add_solution_values() {
  return solution_values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::MPSolutionValue >&
MPSolutionResponse::solution_values() const {
  return solution_values_;
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::MPSolutionValue >*
MPSolutionResponse::mutable_solution_values() {
  return &solution_values_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace operations_research

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::operations_research::MPModelRequest_OptimizationProblemType>() {
  return ::operations_research::MPModelRequest_OptimizationProblemType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::operations_research::MPSolutionResponse_ResultStatus>() {
  return ::operations_research::MPSolutionResponse_ResultStatus_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_linear_5fsolver_2flinear_5fsolver_2eproto__INCLUDED
